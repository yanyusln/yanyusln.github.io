<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Express入门</title>
      <link href="/2024/10/22/Express%E5%85%A5%E9%97%A8/"/>
      <url>/2024/10/22/Express%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Express.js 是由 TJ Holowaychuk 开发的，现在由 Node.js 基金会和众多开源贡献者维护。它是一个保持最低程度规模的灵活 Node.js Web 应用程序框架，为 Web 和移动应用程序提供一组强大的功能。</p></blockquote><h3 id="一、安装与基本使用"><a href="#一、安装与基本使用" class="headerlink" title="一、安装与基本使用"></a>一、安装与基本使用</h3><ol><li><p><strong>安装Node.js</strong>：</p><ul><li>首先，需要在计算机上安装Node.js。Node.js是一个基于Chrome V8引擎的JavaScript运行环境，它允许JavaScript代码在服务器端运行。</li></ul></li><li><p><strong>安装Express</strong>：</p><ul><li><p>使用npm（Node.js的包管理器）来安装Express。在项目目录下，打开命令行工具，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure></li><li><p>这将下载并安装Express及其依赖项。</p></li></ul></li><li><p><strong>创建简单的Express服务器</strong>：</p><ul><li><p>创建一个JavaScript文件（例如<code>app.js</code>），并在其中编写以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   res.<span class="title function_">send</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这段代码创建了一个Express应用程序，定义了一个简单的路由，当访问根路径时返回“Hello World!”。</p></li></ul></li><li><p><strong>启动服务器</strong>：</p><ul><li><p>在命令行中，进入项目目录，并执行以下命令来启动应用程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure></li><li><p>将看到控制台输出的服务器运行消息，并且可以在浏览器中访问<code>http://localhost:3000</code>，看到“Hello World!”的消息显示在页面上。</p></li></ul></li></ol><h3 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h3><ol><li><strong>路由</strong>：<ul><li>路由是指定义应用程序端点的路径以及处理这些路径上请求的方式。在Express中，可以使用<code>app.METHOD(PATH, HANDLER)</code>语法来定义路由，其中<code>METHOD</code>是HTTP请求方法（如GET、POST等），<code>PATH</code>是请求的路径，<code>HANDLER</code>是处理请求的函数。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/about&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;About page&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>中间件</strong>：<ul><li>中间件是一种函数，可以访问请求对象（req）、响应对象（res）和应用程序请求-响应周期中的下一个中间件函数。每个中间件函数都有权访问请求对象（req）、响应对象（res），以及管道中下一个中间件函数的引用（next）。中间件常用于执行以下任务：<ul><li>执行任何代码。</li><li>修改请求和响应对象。</li><li>结束请求-响应循环。</li><li>调用堆栈中的下一个中间件函数。</li></ul></li><li>如果当前中间件没有结束请求-响应循环，则必须调用<code>next()</code>函数以将控制权传递给下一个中间件函数。否则，请求将保持挂起状态。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Time: &#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>请求和响应对象</strong>：<ul><li><code>req</code>（请求对象）包含了与HTTP请求相关的所有信息，如请求头、请求参数等。</li><li><code>res</code>（响应对象）用于发送HTTP响应到客户端，如设置状态码、发送数据等。</li></ul></li></ol><h3 id="三、进一步学习"><a href="#三、进一步学习" class="headerlink" title="三、进一步学习"></a>三、进一步学习</h3><ol><li><p><strong>处理静态文件</strong>：</p><ul><li><p>可以使用<code>express.static</code>中间件来处理静态文件，如HTML、CSS、JavaScript和图像文件。例如，要将<code>public</code>目录作为静态文件的根目录，可以使用以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>构建API</strong>：</p><ul><li>Express非常适合构建RESTful API。可以使用不同的HTTP请求方法来处理不同的操作，如GET用于获取数据，POST用于创建数据，PUT用于更新数据，DELETE用于删除数据。</li></ul></li><li><p><strong>使用模板引擎</strong>：</p><ul><li>Express支持多种模板引擎，如Pug、EJS等。可以使用模板引擎来生成动态HTML内容。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">set</span>(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>, &#123; <span class="attr">title</span>: <span class="string">&#x27;Hello&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>错误处理</strong>：</p><ul><li><p>Express允许你定义全局错误处理中间件，以捕获和处理应用程序中发生的错误。例如，可以使用以下代码来捕获并处理所有错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(err.<span class="property">stack</span>);  </span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;Something broke!&#x27;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="四、参考资源"><a href="#四、参考资源" class="headerlink" title="四、参考资源"></a>四、参考资源</h3><ol><li><strong>官方网站</strong>：Express.js的官方网站（<a href="https://expressjs.com/">https://expressjs.com</a>）提供了详细的文档和示例代码，是学习Express.js的最佳资源。</li><li><strong>在线教程</strong>：可以在各大在线教育平台上找到Express.js的在线教程和视频课程，这些教程通常提供了丰富的实例和案例，有助于更好地理解Express.js的使用。</li><li><strong>社区支持</strong>：Express.js拥有一个活跃的社区，可以在Stack Overflow、GitHub等平台上找到关于Express.js的问题和解决方案。</li></ol><p>通过以上入门详解，你可以开始使用Express.js来构建自己的Web应用程序和API。随着对Express.js的深入理解，你将能够掌握更多高级功能和最佳实践，以构建更复杂和高效的Web应用程序。</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Koa.js入门</title>
      <link href="/2024/10/22/Koa-js%E5%85%A5%E9%97%A8/"/>
      <url>/2024/10/22/Koa-js%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Koa.js（简称Koa）是一个基于Node.js的Web框架，由Express的创建者TJ Holowaychuk设计，并由Yahoo和Visionscaper联合推出。以下是对Koa.js的入门与详解：</p></blockquote><h3 id="一、Koa-js简介"><a href="#一、Koa-js简介" class="headerlink" title="一、Koa.js简介"></a>一、Koa.js简介</h3><p>Koa.js旨在成为更轻量、更灵活、更优雅的Web框架。与Express相比，Koa没有内置许多功能，如路由和中间件，而是提供了一个小而强大的核心，让开发者可以根据需要添加所需的功能。这使得Koa非常灵活，并且适合构建各种规模的Web应用和API。</p><h3 id="二、安装与基本使用"><a href="#二、安装与基本使用" class="headerlink" title="二、安装与基本使用"></a>二、安装与基本使用</h3><ol><li><p><strong>安装Node.js</strong>：</p><ul><li>首先，需要在计算机上安装Node.js。Node.js是一个基于Chrome V8引擎的JavaScript运行环境，允许JavaScript代码在服务器端运行。</li></ul></li><li><p><strong>安装Koa</strong>：</p><ul><li>使用npm（Node.js的包管理器）来安装Koa。在项目目录下，打开命令行工具，执行以下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa</span><br></pre></td></tr></table></figure></li><li>这将下载并安装Koa及其依赖项。</li></ul></li><li><p><strong>创建简单的Koa应用</strong>：</p><ul><li>创建一个JavaScript文件（例如<code>app.js</code>），并在其中编写以下代码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&#x27;Hello, Koa!&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器运行在 http://localhost:3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>这段代码创建了一个Koa应用程序，定义了一个简单的中间件，当访问服务器时返回“Hello, Koa!”的消息。</li></ul></li><li><p><strong>启动服务器</strong>：</p><ul><li>在命令行中，进入项目目录，并执行以下命令来启动应用程序：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure></li><li>将看到控制台输出的服务器运行消息，并且可以在浏览器中访问<code>http://localhost:3000</code>，看到“Hello, Koa!”的消息显示在页面上。</li></ul></li></ol><h3 id="三、核心概念"><a href="#三、核心概念" class="headerlink" title="三、核心概念"></a>三、核心概念</h3><ol><li><p><strong>中间件</strong>：</p><ul><li>中间件是Koa的核心概念之一。中间件是处理请求和响应的一种函数，多个中间件可以链式组合，依次处理请求。每个中间件既可以处理请求，也可以修改响应。</li><li>中间件函数接收一个<code>ctx</code>（上下文）对象作为参数，该对象包含了请求和响应的信息。中间件可以使用<code>async</code>和<code>await</code>来处理异步操作，这使得代码更加简洁和易于理解。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>上下文（ctx）</strong>：</p><ul><li><code>ctx</code>是Koa中的上下文对象，它集成了Node.js原生的<code>req</code>和<code>res</code>对象的功能。<code>ctx</code>提供了许多便捷的属性和方法来访问请求和响应的信息，如<code>ctx.request</code>、<code>ctx.response</code>、<code>ctx.body</code>等。</li><li><code>ctx.request</code>是Koa封装的请求对象，它基于Node.js原生的<code>req</code>对象，但提供了更高层次的API，方便开发者访问请求信息。<code>ctx.response</code>是Koa封装的响应对象，它允许开发者以更简洁的方式设置响应内容、状态码和响应头等。</li></ul></li><li><p><strong>路由</strong>：</p><ul><li>虽然Koa本身没有内置路由功能，但可以使用第三方中间件（如<code>koa-router</code>）来实现路由功能。路由中间件允许你定义不同的路径和对应的处理函数，以处理不同的请求。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 Koa.js 中定义路由的方式类似于 Express.js，但更加简洁：</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (ctx.<span class="property">path</span> === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&#x27;Index Page&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx.<span class="property">path</span> === <span class="string">&#x27;/about&#x27;</span>) &#123;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&#x27;About Page&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="四、进一步学习"><a href="#四、进一步学习" class="headerlink" title="四、进一步学习"></a>四、进一步学习</h3></li></ul></li><li><p><strong>错误处理</strong>：</p><ul><li>Koa提供了完整的错误处理方案。你可以通过自定义Error对象和异常捕获来处理错误，并在任何地方抛出错误并统一处理。这增强了程序的健壮性。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err, ctx</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;server error&#x27;</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>中间件的使用与组合</strong>：</p><ul><li>Koa的中间件机制非常强大和灵活。你可以编写自己的中间件来处理特定的请求或响应逻辑，并将其组合在一起以构建复杂的Web应用。</li></ul></li><li><p><strong>与数据库和其他服务的集成</strong>：</p><ul><li>Koa可以轻松地与各种数据库（如MongoDB、MySQL等）和其他服务（如Redis、Memcached等）集成。你可以使用相应的Node.js库或中间件来实现这些集成。</li></ul></li><li><p><strong>构建API</strong>：</p><ul><li>Koa非常适合构建RESTful API。你可以使用中间件来处理不同的HTTP请求方法（如GET、POST、PUT、DELETE等），并返回相应的JSON数据作为响应。</li></ul></li></ol><h3 id="五、参考资源"><a href="#五、参考资源" class="headerlink" title="五、参考资源"></a>五、参考资源</h3><ol><li><strong>官方网站</strong>：Koa.js的官方网站（<a href="https://koajs.com/">https://koajs.com</a>）提供了详细的文档和示例代码，是学习Koa.js的最佳资源。</li><li><strong>在线教程</strong>：可以在各大在线教育平台上找到Koa.js的在线教程和视频课程，这些教程通常提供了丰富的实例和案例，有助于更好地理解Koa.js的使用。</li><li><strong>社区支持</strong>：Koa.js拥有一个活跃的社区，你可以在GitHub、Stack Overflow等平台上找到关于Koa.js的问题和解决方案。</li></ol><p>通过以上入门与详解，你可以开始使用Koa.js来构建自己的Web应用程序和API。随着对Koa.js的深入理解，你将能够掌握更多高级功能和最佳实践，以构建更复杂和高效的Web应用程序。</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3项目实战之脚手架入门</title>
      <link href="/2024/09/19/vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E8%84%9A%E6%89%8B%E6%9E%B6%E5%85%A5%E9%97%A8/"/>
      <url>/2024/09/19/vue3%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E8%84%9A%E6%89%8B%E6%9E%B6%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环境准备与项目初始化"><a href="#1-环境准备与项目初始化" class="headerlink" title="1. 环境准备与项目初始化"></a>1. 环境准备与项目初始化</h1><h2 id="1-1-检查-Node-js-环境"><a href="#1-1-检查-Node-js-环境" class="headerlink" title="1.1 检查 Node.js 环境"></a>1.1 检查 Node.js 环境</h2><p>确保本地开发环境中已安装 Node.js，可以通过在终端执行 <code>node -v</code> 来检查 Node.js 版本。当前 Vite 推荐使用 Node.js 的版本为 14.18.0 或更高版本。</p><h2 id="1-2-使用-Vite-创建-Vue3-项目"><a href="#1-2-使用-Vite-创建-Vue3-项目" class="headerlink" title="1.2 使用 Vite 创建 Vue3 项目"></a>1.2 使用 Vite 创建 Vue3 项目</h2><p>通过 npm 或 yarn 安装 Vite，并使用以下命令创建一个新的 Vue3 项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest my-vue-app --template vue</span><br></pre></td></tr></table></figure><p>该命令会引导你完成项目创建流程，包括选择项目模板、安装依赖等步骤。项目创建完成后，进入项目目录，安装额外的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-vue-app</span><br><span class="line">npm install --save vue-router@4 axios pinia element-plus</span><br></pre></td></tr></table></figure><p>接下来，安装 TypeScript 支持：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev typescript @vitejs/plugin-vue @vitejs/plugin-typescript</span><br></pre></td></tr></table></figure><p>在项目根目录下创建 <code>tsconfig.json</code> 文件，配置 TypeScript 编译选项。</p><h1 id="2-技术框架配置"><a href="#2-技术框架配置" class="headerlink" title="2. 技术框架配置"></a>2. 技术框架配置</h1><h2 id="2-1-TypeScript-配置"><a href="#2-1-TypeScript-配置" class="headerlink" title="2.1 TypeScript 配置"></a>2.1 TypeScript 配置</h2><p>在 <code>tsconfig.json</code> 中设置项目的基础 TypeScript 配置，包括 <code>target</code>, <code>module</code>, <code>strict</code> 等选项，以确保代码的类型安全和质量。</p><h2 id="2-2-Pinia-状态管理"><a href="#2-2-Pinia-状态管理" class="headerlink" title="2.2 Pinia 状态管理"></a>2.2 Pinia 状态管理</h2><p>在项目中设置 Pinia 作为状态管理库，创建 <code>store</code> 目录，并定义全局状态管理逻辑。</p><h2 id="2-3-Vue-Router-路由配置"><a href="#2-3-Vue-Router-路由配置" class="headerlink" title="2.3 Vue Router 路由配置"></a>2.3 Vue Router 路由配置</h2><p>安装并配置 Vue Router，创建 <code>router</code> 目录，并设置路由规则，以支持单页面应用的页面路由跳转。</p><h2 id="2-4-Axios-网络请求"><a href="#2-4-Axios-网络请求" class="headerlink" title="2.4 Axios 网络请求"></a>2.4 Axios 网络请求</h2><p>配置 Axios 作为 HTTP 客户端，设置基础 URL、拦截器等，以简化网络请求流程。</p><h2 id="2-5-Element-Plus-UI-框架"><a href="#2-5-Element-Plus-UI-框架" class="headerlink" title="2.5 Element Plus UI 框架"></a>2.5 Element Plus UI 框架</h2><p>安装 Element Plus 并按需引入组件，配置其样式和脚本，以快速构建界面。</p><h1 id="3-项目开发与测试"><a href="#3-项目开发与测试" class="headerlink" title="3. 项目开发与测试"></a>3. 项目开发与测试</h1><h2 id="3-1-组件与视图开发"><a href="#3-1-组件与视图开发" class="headerlink" title="3.1 组件与视图开发"></a>3.1 组件与视图开发</h2><p>开发单文件组件（.vue 文件），使用 Vue3 的 Composition API 组织逻辑和状态。</p><h2 id="3-2-单元测试"><a href="#3-2-单元测试" class="headerlink" title="3.2 单元测试"></a>3.2 单元测试</h2><p>使用 Vue Test Utils 和 Vite 的测试工具配置单元测试，确保组件和逻辑的正确性。</p><h2 id="3-3-端到端测试"><a href="#3-3-端到端测试" class="headerlink" title="3.3 端到端测试"></a>3.3 端到端测试</h2><p>使用 Cypress 或类似工具进行端到端测试，模拟用户交互，确保应用流程符合预期。</p><h1 id="4-代码质量和风格"><a href="#4-代码质量和风格" class="headerlink" title="4. 代码质量和风格"></a>4. 代码质量和风格</h1><h2 id="4-1-ESLint-代码质量检查"><a href="#4-1-ESLint-代码质量检查" class="headerlink" title="4.1 ESLint 代码质量检查"></a>4.1 ESLint 代码质量检查</h2><p>集成 ESLint，并配置相应的规则，以自动检测代码中的错误和潜在问题。</p><h2 id="4-2-Prettier-代码格式化"><a href="#4-2-Prettier-代码格式化" class="headerlink" title="4.2 Prettier 代码格式化"></a>4.2 Prettier 代码格式化</h2><p>使用 Prettier 进行代码格式化，确保代码风格的统一和整洁。</p><h1 id="5-部署与监控"><a href="#5-部署与监控" class="headerlink" title="5. 部署与监控"></a>5. 部署与监控</h1><h2 id="5-1-项目构建"><a href="#5-1-项目构建" class="headerlink" title="5.1 项目构建"></a>5.1 项目构建</h2><p>配置 Vite 的构建脚本，使用 <code>npm run build</code> 命令打包应用，准备部署。</p><h2 id="5-2-自动化部署"><a href="#5-2-自动化部署" class="headerlink" title="5.2 自动化部署"></a>5.2 自动化部署</h2><p>集成 CI&#x2F;CD 流程，使用 GitHub Actions 或 GitLab CI 自动化测试和部署流程。</p><h2 id="5-3-性能监控"><a href="#5-3-性能监控" class="headerlink" title="5.3 性能监控"></a>5.3 性能监控</h2><p>使用 Vercel 或 Netlify 等平台部署应用，并利用其性能监控工具监控应用运行情况。</p><h1 id="2-技术框架配置-1"><a href="#2-技术框架配置-1" class="headerlink" title="2. 技术框架配置"></a>2. 技术框架配置</h1><h2 id="2-1-TypeScript-集成"><a href="#2-1-TypeScript-集成" class="headerlink" title="2.1 TypeScript 集成"></a>2.1 TypeScript 集成</h2><p>TypeScript 作为 JavaScript 的超集，为 Vue 3 项目提供了类型安全和更现代的编码特性。在 Vite 项目中集成 TypeScript，首先需要在项目中安装 TypeScript 相关的依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev typescript @vitejs/plugin-vue@alpha</span><br></pre></td></tr></table></figure><p>接着，在项目根目录下创建 <code>tsconfig.json</code> 文件，配置 TypeScript 的编译选项，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esnext&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es2020&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;preserve&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/**/*.ts&quot;</span><span class="punctuation">,</span> <span class="string">&quot;src/**/*.d.ts&quot;</span><span class="punctuation">,</span> <span class="string">&quot;src/**/*.tsx&quot;</span><span class="punctuation">,</span> <span class="string">&quot;src/**/*.vue&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;node_modules&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在 Vite 配置文件 <code>vite.config.js</code> 中添加 TypeScript 插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> typescript <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-typescript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>(), <span class="title function_">typescript</span>()]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-Pinia-状态管理-1"><a href="#2-2-Pinia-状态管理-1" class="headerlink" title="2.2 Pinia 状态管理"></a>2.2 Pinia 状态管理</h2><p>Pinia 是 Vue 3 的状态管理库，用于替代 Vuex。首先安装 Pinia：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pinia</span><br></pre></td></tr></table></figure><p>在项目中创建一个 <code>store</code> 目录，并在其中定义 Pinia 存储：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/store/index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, createStores &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useMyStore = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;myStore&#x27;</span>,</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 可以添加 actions 和 getters 等</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useMyStore;</span><br></pre></td></tr></table></figure><p>在 <code>main.ts</code> 中初始化 Pinia 并将其挂载到 Vue 应用上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> useMyStore <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(useMyStore);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="2-3-Vue-Router-路由管理"><a href="#2-3-Vue-Router-路由管理" class="headerlink" title="2.3 Vue Router 路由管理"></a>2.3 Vue Router 路由管理</h2><p>Vue Router 是 Vue 官方的路由管理器，用于构建单页面应用。首先安装 Vue Router：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router@4</span><br></pre></td></tr></table></figure><p>创建路由文件和目录，定义路由配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/router/index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../views/Home.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 其他路由...</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(process.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><p>在 <code>main.ts</code> 中引入并使用 Vue Router：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="2-4-Axios-网络请求-1"><a href="#2-4-Axios-网络请求-1" class="headerlink" title="2.4 Axios 网络请求"></a>2.4 Axios 网络请求</h2><p>Axios 是一个基于 promise 的 HTTP 库，用于浏览器和 node.js。首先安装 Axios：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><p>在项目中创建一个 Axios 实例并配置基础 URL 和拦截器等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/utils/axios.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: process.<span class="property">env</span>.<span class="property">VITE_API_BASE_URL</span>,</span><br><span class="line">  <span class="comment">// 其他配置...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance;</span><br></pre></td></tr></table></figure><p>在组件中使用 Axios 实例进行数据请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line"><span class="keyword">import</span> axiosInstance <span class="keyword">from</span> <span class="string">&#x27;@/utils/axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line">axiosInstance.<span class="title function_">get</span>(<span class="string">&#x27;/some-endpoint&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理响应数据</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误情况</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="2-5-Element-Plus-UI-框架-1"><a href="#2-5-Element-Plus-UI-框架-1" class="headerlink" title="2.5 Element Plus UI 框架"></a>2.5 Element Plus UI 框架</h2><p>Element Plus 是一个 Vue 3 的组件库，提供了一套丰富的组件用于构建用户界面。首先安装 Element Plus：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install element-plus</span><br></pre></td></tr></table></figure><p>在 <code>main.ts</code> 中全局引入 Element Plus 并使用其样式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在组件中使用 Element Plus 组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-button&gt;Button&lt;/el-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="2-6-测试"><a href="#2-6-测试" class="headerlink" title="2.6 测试"></a>2.6 测试</h2><p>为了确保代码质量和功能的稳定性，使用 Vue Test Utils 和 Jest 进行单元测试和端到端测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @vue/test-utils jest</span><br></pre></td></tr></table></figure><p>创建测试文件，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/MyComponent.spec.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/MyComponent.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;MyComponent&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;renders props.msg&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="title function_">mount</span>(<span class="title class_">MyComponent</span>, &#123;</span><br><span class="line">      <span class="attr">props</span>: &#123; msg &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="title function_">text</span>()).<span class="title function_">toMatch</span>(msg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>配置 Jest 以使用 Vue Test Utils：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jest.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">preset</span>: <span class="string">&#x27;@vue/cli-plugin-unit-jest&#x27;</span>,</span><br><span class="line">  <span class="attr">transform</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;^.+\\.vue$&#x27;</span>: <span class="string">&#x27;vue-jest&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run test</span><br></pre></td></tr></table></figure><h2 id="2-7-代码质量和风格"><a href="#2-7-代码质量和风格" class="headerlink" title="2.7 代码质量和风格"></a>2.7 代码质量和风格</h2><p>为了统一代码风格和提高代码质量，使用 ESLint 和 Prettier：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint-plugin-prettier prettier eslint-config-prettier</span><br></pre></td></tr></table></figure><p>创建 <code>.eslintrc.js</code> 配置文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:@typescript-eslint/recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:prettier/recommended&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">parser</span>: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;@typescript-eslint&#x27;</span>, <span class="string">&#x27;prettier&#x27;</span>],</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;prettier/prettier&#x27;</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>package.json</code> 中添加 Prettier 配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;prettier&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;semi&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;singleQuote&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;printWidth&quot;</span><span class="punctuation">:</span> <span class="number">80</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>运行 ESLint 和 Prettier：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx eslint --ext .js,.ts,.vue src/</span><br><span class="line">npx prettier --write src/</span><br></pre></td></tr></table></figure><h2 id="2-8-部署"><a href="#2-8-部署" class="headerlink" title="2.8 部署"></a>2.8 部署</h2><p>部署 Vue 3 应用到生产环境，可以使用 Vite 的构建命令来生成优化后的静态资源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>生成的 <code>dist</code> 目录包含了用于生产的静态资源，可以部署到各种静态文件服务器或 CDN 上。</p><h1 id="3-核心库集成"><a href="#3-核心库集成" class="headerlink" title="3. 核心库集成"></a>3. 核心库集成</h1><h2 id="3-1-Axios-网络请求"><a href="#3-1-Axios-网络请求" class="headerlink" title="3.1 Axios 网络请求"></a>3.1 Axios 网络请求</h2><p>   Axios 是一个基于 promise 的 HTTP 客户端，适用于浏览器和 node.js 环境。在 Vue 3 项目中，Axios 通常用于处理网络请求。</p><ul><li>安装 Axios：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure></li><li>创建 Axios 实例并配置基础 URL：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> service = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: process.<span class="property">env</span>.<span class="property">VITE_API_BASE_URL</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service;</span><br></pre></td></tr></table></figure></li><li>在组件中使用 Axios 发送请求：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> service <span class="keyword">from</span> <span class="string">&#x27;/axios-service&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> service.<span class="title function_">get</span>(<span class="string">&#x27;/data&#x27;</span>);</span><br><span class="line">        data.<span class="property">value</span> = response.<span class="property">data</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error fetching data: &#x27;</span>, error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; data &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-Element-Plus-UI-组件库"><a href="#3-2-Element-Plus-UI-组件库" class="headerlink" title="3.2 Element Plus UI 组件库"></a>3.2 Element Plus UI 组件库</h2><p>   Element Plus 是一个基于 Vue 3 的组件库，提供了一系列预设计的组件，以快速构建高质量的前端界面。</p><ul><li>安装 Element Plus：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install element-plus</span><br></pre></td></tr></table></figure></li><li>全局注册 Element Plus 组件：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li>在组件中使用 Element Plus 组件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-button type=&quot;primary&quot;&gt;Element Plus Button&lt;/el-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // Component logic</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="4-技术框架补充"><a href="#4-技术框架补充" class="headerlink" title="4. 技术框架补充"></a>4. 技术框架补充</h1><h2 id="4-1-TypeScript-配置"><a href="#4-1-TypeScript-配置" class="headerlink" title="4.1 TypeScript 配置"></a>4.1 TypeScript 配置</h2><p>   TypeScript 为 JavaScript 提供了类型系统，增强了代码的可读性和可维护性。</p><ul><li>在 Vite 中使用 TypeScript：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esnext&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es2020&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;preserve&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/**/*.ts&quot;</span><span class="punctuation">,</span> <span class="string">&quot;src/**/*.d.ts&quot;</span><span class="punctuation">,</span> <span class="string">&quot;src/**/*.tsx&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-Pinia-状态管理"><a href="#4-2-Pinia-状态管理" class="headerlink" title="4.2 Pinia 状态管理"></a>4.2 Pinia 状态管理</h2><p>   Pinia 是 Vue 3 的官方状态管理库，用于构建高效且可扩展的应用程序。</p><ul><li>安装 Pinia：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pinia</span><br></pre></td></tr></table></figure></li><li>创建 Pinia 存储：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useMyStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;myStore&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// Other options...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-3-Vue-Router-路由管理"><a href="#4-3-Vue-Router-路由管理" class="headerlink" title="4.3 Vue Router 路由管理"></a>4.3 Vue Router 路由管理</h2><p>   Vue Router 是 Vue 3 的官方路由管理器，用于构建单页面应用程序。</p><ul><li>安装 Vue Router：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router@4</span><br></pre></td></tr></table></figure></li><li>创建和配置路由：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../views/Home.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">  <span class="comment">// Define other routes...</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(process.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-4-代码质量和风格"><a href="#4-4-代码质量和风格" class="headerlink" title="4.4 代码质量和风格"></a>4.4 代码质量和风格</h2><p>   使用 ESLint 和 Prettier 来确保代码质量和风格一致性。</p><ul><li>安装 ESLint 和 Prettier：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint prettier eslint-plugin-prettier --save-dev</span><br></pre></td></tr></table></figure></li><li>配置 ESLint 和 Prettier：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;plugin:vue/vue3-essential&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;eslint:recommended&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;plugin:prettier/recommended&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prettier/prettier&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-5-测试"><a href="#4-5-测试" class="headerlink" title="4.5 测试"></a>4.5 测试</h2><p>   使用 Vue Test Utils 和 Jest 进行单元测试和集成测试。</p><ul><li>安装 Vue Test Utils 和 Jest：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @vue/test-utils jest</span><br></pre></td></tr></table></figure></li><li>编写测试用例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/test-utils&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/MyComponent.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;MyComponent&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;renders properly&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="title function_">shallowMount</span>(<span class="title class_">MyComponent</span>);</span><br><span class="line">    <span class="title function_">expect</span>(wrapper.<span class="title function_">text</span>()).<span class="title function_">toMatch</span>(<span class="string">&#x27;Expected text&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-6-部署"><a href="#4-6-部署" class="headerlink" title="4.6 部署"></a>4.6 部署</h2><p>   使用 Vite 的构建命令来准备生产环境的部署。</p><ul><li>构建生产环境：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li><li>部署到服务器或静态网站托管服务。<h1 id="4-项目测试策略"><a href="#4-项目测试策略" class="headerlink" title="4. 项目测试策略"></a>4. 项目测试策略</h1></li></ul><h2 id="4-1-单元测试"><a href="#4-1-单元测试" class="headerlink" title="4.1 单元测试"></a>4.1 单元测试</h2><p>单元测试是确保每个组件或模块按预期工作的基石。在Vue 3项目中，我们可以使用Vue Test Utils结合Jest或Vitest来执行单元测试。</p><ul><li><strong>测试框架选择</strong>：Jest和Vitest都是流行的测试框架，Vitest提供了更快的执行速度，因为它利用了Vite的底层优化。</li><li><strong>Vue Test Utils</strong>：这是官方提供的测试工具集，用于模拟Vue组件的行为并进行断言。</li><li><strong>测试覆盖率</strong>：确保关键功能和边缘情况都编写了测试用例，目标是达到90%以上的代码覆盖率。</li><li><strong>持续集成</strong>：集成测试到CI&#x2F;CD流程中，确保每次提交都会运行测试套件，快速发现集成问题。</li></ul><h2 id="4-2-端到端测试"><a href="#4-2-端到端测试" class="headerlink" title="4.2 端到端测试"></a>4.2 端到端测试</h2><p>端到端测试用于验证整个应用的流程是否符合用户的操作预期。</p><ul><li><strong>Cypress</strong>：一个流行的端到端测试框架，提供了丰富的API和直观的测试运行界面。</li><li><strong>测试场景</strong>：包括用户登录、导航、数据加载和表单提交等关键用户流程。</li><li><strong>测试数据</strong>：使用Mock服务模拟后端API，确保测试的独立性和稳定性。</li><li><strong>性能监测</strong>：集成性能监测工具，如Lighthouse，以确保应用在不同网络条件下的性能表现。</li></ul><h2 id="4-3-代码质量和风格"><a href="#4-3-代码质量和风格" class="headerlink" title="4.3 代码质量和风格"></a>4.3 代码质量和风格</h2><p>代码质量和风格是项目维护和开发效率的关键。</p><ul><li><strong>ESLint</strong>：集成ESLint进行代码质量检查，配置规则以符合项目代码风格。</li><li><strong>Prettier</strong>：使用Prettier进行代码格式化，确保代码风格的一致性。</li><li><strong>TypeScript</strong>：利用TypeScript的类型系统来提高代码的健壮性和可维护性。</li></ul><h2 id="4-4-部署策略"><a href="#4-4-部署策略" class="headerlink" title="4.4 部署策略"></a>4.4 部署策略</h2><p>部署是将应用发布到生产环境的过程。</p><ul><li><strong>Vite构建</strong>：利用Vite的构建优势，生成优化后的静态资源。</li><li><strong>Docker容器化</strong>：使用Docker容器化应用，确保在不同环境中的一致性。</li><li><strong>蓝绿部署</strong>：采用蓝绿部署策略，减少部署过程中的停机时间。</li><li><strong>监控和日志</strong>：集成监控系统和日志收集，快速响应生产环境中的问题。</li></ul><h2 id="4-5-持续集成和持续部署"><a href="#4-5-持续集成和持续部署" class="headerlink" title="4.5 持续集成和持续部署"></a>4.5 持续集成和持续部署</h2><p>CI&#x2F;CD是现代软件开发流程的重要组成部分。</p><ul><li><strong>自动化测试</strong>：集成自动化测试到CI流程，确保代码质量。</li><li><strong>自动化部署</strong>：配置CD流程，实现一键部署到测试、预发布和生产环境。</li><li><strong>环境隔离</strong>：确保开发、测试和生产环境的隔离，避免相互影响。</li></ul><h2 id="4-6-性能优化"><a href="#4-6-性能优化" class="headerlink" title="4.6 性能优化"></a>4.6 性能优化</h2><p>性能优化是提升用户体验的关键。</p><ul><li><strong>代码分割</strong>：利用Vite的代码分割功能，按需加载组件和库。</li><li><strong>服务端渲染</strong>：考虑使用服务端渲染(SSR)或静态站点生成(SSG)来提升首屏加载速度。</li><li><strong>缓存策略</strong>：配置合理的缓存策略，减少网络请求和提高响应速度。</li></ul><h2 id="4-7-安全性考虑"><a href="#4-7-安全性考虑" class="headerlink" title="4.7 安全性考虑"></a>4.7 安全性考虑</h2><p>安全性是应用开发不可忽视的方面。</p><ul><li><strong>依赖管理</strong>：定期检查项目依赖的安全性，使用工具如npm audit。</li><li><strong>安全头</strong>：配置安全相关的HTTP头，如Content Security Policy(CSP)。</li><li><strong>数据保护</strong>：确保用户数据的安全，遵守数据保护法规如GDPR。<h1 id="5-代码质量与风格"><a href="#5-代码质量与风格" class="headerlink" title="5. 代码质量与风格"></a>5. 代码质量与风格</h1></li></ul><h2 id="5-1-代码质量保证"><a href="#5-1-代码质量保证" class="headerlink" title="5.1 代码质量保证"></a>5.1 代码质量保证</h2><p>为了确保代码质量，项目中集成了ESLint进行语法检查和代码风格规范。通过配置<code>.eslintrc.js</code>文件，我们制定了一套符合项目标准的规则，包括但不限于：</p><ul><li>禁止使用未定义的变量</li><li>强制使用箭头函数</li><li>要求使用模板字符串代替传统的字符串连接</li><li>限制循环中同步操作，以避免阻塞UI线程</li></ul><p>此外，通过Prettier插件与ESLint集成，实现了代码的自动格式化，确保了代码风格的统一性。</p><h2 id="5-2-代码风格统一"><a href="#5-2-代码风格统一" class="headerlink" title="5.2 代码风格统一"></a>5.2 代码风格统一</h2><p>项目采用了Prettier进行代码格式化，通过<code>.prettierrc</code>配置文件来定义代码的格式化规则，例如：</p><ul><li>使用单引号代替双引号</li><li>在对象或数组的最后一个元素后不添加逗号</li><li>函数声明时括号前后不加空格</li></ul><p>这些规则有助于团队成员之间保持代码风格的一致性，降低代码审查的难度。</p><h2 id="5-3-测试驱动开发"><a href="#5-3-测试驱动开发" class="headerlink" title="5.3 测试驱动开发"></a>5.3 测试驱动开发</h2><p>为了提高代码的可靠性和减少bug，项目采用了Vue Test Utils和Jest作为测试框架，进行单元测试和集成测试。测试覆盖率作为代码质量的一个重要指标，被纳入了项目的CI&#x2F;CD流程中，确保每次提交的代码都能通过测试。</p><ul><li>组件测试：针对每个Vue组件编写测试用例，确保组件的功能性和渲染正确性。</li><li>路由守卫测试：验证Vue Router的路由守卫是否按预期工作。</li><li>状态管理测试：对Pinia存储的getters、actions和mutations进行测试，确保状态管理的准确性。</li></ul><h2 id="5-4-持续集成与部署"><a href="#5-4-持续集成与部署" class="headerlink" title="5.4 持续集成与部署"></a>5.4 持续集成与部署</h2><p>项目配置了GitHub Actions进行持续集成，每次代码提交都会触发自动化的构建和测试流程。通过配置<code>.github/workflows</code>目录下的CI配置文件，实现了以下功能：</p><ul><li>自动化构建：使用Vite对项目进行打包构建。</li><li>自动化测试：运行项目中的所有测试用例。</li><li>代码质量检测：利用ESLint和Prettier检查代码质量。</li><li>部署：测试通过后，自动将构建产物部署到GitHub Pages或其他指定的服务器。</li></ul><p>通过持续集成与部署，项目能够快速响应代码变更，确保软件的持续交付和高质量。</p><h1 id="6-项目部署"><a href="#6-项目部署" class="headerlink" title="6. 项目部署"></a>6. 项目部署</h1><h2 id="6-1-部署流程概述"><a href="#6-1-部署流程概述" class="headerlink" title="6.1 部署流程概述"></a>6.1 部署流程概述</h2><p>项目部署是将开发完成的应用发布到服务器，供用户访问的过程。Vue3项目通常涉及以下步骤：</p><ul><li>代码构建：使用Vite提供的构建命令将源代码打包成适用于生产环境的文件。</li><li>静态资源托管：将构建生成的静态资源（JavaScript、CSS、图片等）上传到静态资源服务器或CDN。</li><li>服务器配置：如果应用包含后端服务，需要配置相应的服务器环境。</li></ul><h2 id="6-2-代码构建与优化"><a href="#6-2-代码构建与优化" class="headerlink" title="6.2 代码构建与优化"></a>6.2 代码构建与优化</h2><p>构建过程是将项目中的源代码、模板、样式和资源文件转换成浏览器可识别的格式。Vite在构建时会进行以下优化：</p><ul><li>代码压缩：减少文件体积，提高加载速度。</li><li>代码分割：实现按需加载，减少初次加载时间。</li><li>服务端渲染（SSR）：根据需要配置服务端渲染，提升首屏加载速度。</li></ul><h2 id="6-3-静态资源托管"><a href="#6-3-静态资源托管" class="headerlink" title="6.3 静态资源托管"></a>6.3 静态资源托管</h2><p>静态资源可以通过以下几种方式进行托管：</p><ul><li>使用传统的Web服务器，如Apache或Nginx。</li><li>使用对象存储服务，如Amazon S3。</li><li>使用CDN服务，如Cloudflare或Netlify，以提高全球访问速度。</li></ul><h2 id="6-4-自动化部署"><a href="#6-4-自动化部署" class="headerlink" title="6.4 自动化部署"></a>6.4 自动化部署</h2><p>自动化部署可以通过CI&#x2F;CD（持续集成&#x2F;持续部署）工具实现，如GitHub Actions、GitLab CI&#x2F;CD或Jenkins。自动化部署流程包括：</p><ul><li>代码提交：开发者将代码推送到代码仓库。</li><li>自动化测试：运行测试用例，确保代码质量。</li><li>构建与部署：通过自动化脚本将代码构建并部署到服务器。</li></ul><h2 id="6-5-环境变量与配置"><a href="#6-5-环境变量与配置" class="headerlink" title="6.5 环境变量与配置"></a>6.5 环境变量与配置</h2><p>在部署过程中，需要正确配置环境变量和应用设置，以适应不同的运行环境：</p><ul><li>使用<code>.env</code>文件区分不同环境的配置。</li><li>通过Vite的<code>defineConfig</code>函数配置应用的基础路径、API代理等。</li></ul><h2 id="6-6-监控与日志"><a href="#6-6-监控与日志" class="headerlink" title="6.6 监控与日志"></a>6.6 监控与日志</h2><p>部署后，需要对应用进行监控和日志记录，以便及时发现并解决问题：</p><ul><li>使用应用性能监控(APM)工具，如New Relic或Datadog。</li><li>配置日志管理系统，如ELK Stack或Fluentd，收集和分析日志。</li></ul><h2 id="6-7-安全性考虑"><a href="#6-7-安全性考虑" class="headerlink" title="6.7 安全性考虑"></a>6.7 安全性考虑</h2><p>保证应用的安全性是部署过程中的重要环节：</p><ul><li>使用HTTPS协议保障数据传输安全。</li><li>定期更新依赖，修复安全漏洞。</li><li>配置Web应用防火墙(WAF)，防止恶意攻击。</li></ul><h2 id="6-8-回滚策略"><a href="#6-8-回滚策略" class="headerlink" title="6.8 回滚策略"></a>6.8 回滚策略</h2><p>在部署新版本时，应准备好回滚策略，以便在出现问题时迅速恢复到上一个稳定版本：</p><ul><li>确保旧版本的代码和资源文件可以随时回滚。</li><li>使用蓝绿部署或滚动更新策略，减少部署风险。<h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1></li></ul><p>在本研究中，我们探讨了如何使用Vite创建一个包含Vue 3、TypeScript、Pinia、Vue Router、axios和Element Plus等技术栈的现代前端项目脚手架。通过详细的步骤和配置，我们成功搭建了一个高效、可扩展且易于维护的项目基础结构。</p><h3 id="技术选型与项目初始化"><a href="#技术选型与项目初始化" class="headerlink" title="技术选型与项目初始化"></a>技术选型与项目初始化</h3><ul><li>选择了Vite作为构建工具，利用其快速的热模块替换和开发服务器优势。</li><li>引入Vue 3作为核心框架，利用Composition API提供更灵活的组件编写方式。</li><li>TypeScript的加入为项目提供了类型安全和更好的代码编辑体验。</li></ul><h3 id="状态管理与路由"><a href="#状态管理与路由" class="headerlink" title="状态管理与路由"></a>状态管理与路由</h3><ul><li>集成Pinia作为状态管理工具，简化了在Vue 3中的状态管理流程。</li><li>Vue Router的集成使得构建单页面应用变得简单，支持了页面级的路由守卫。</li></ul><h3 id="数据请求与UI组件库"><a href="#数据请求与UI组件库" class="headerlink" title="数据请求与UI组件库"></a>数据请求与UI组件库</h3><ul><li>axios的集成为项目提供了简洁的HTTP客户端，简化了数据请求的处理。</li><li>Element Plus作为UI组件库，提供了丰富的组件和样式，加速了开发流程。</li></ul><h3 id="测试与代码质量"><a href="#测试与代码质量" class="headerlink" title="测试与代码质量"></a>测试与代码质量</h3><ul><li>引入Vitest作为单元测试框架，支持Vue 3和TypeScript，确保代码质量。</li><li>ESLint和Prettier的配置保证了代码风格的统一和最佳实践的遵循。</li></ul><h3 id="部署与持续集成"><a href="#部署与持续集成" class="headerlink" title="部署与持续集成"></a>部署与持续集成</h3><ul><li>配置了项目的部署流程，利用Vite的构建指令生成生产环境下的静态资源。</li><li>通过CI&#x2F;CD工具自动化测试和部署流程，提高了项目的交付效率。</li></ul><h3 id="补充技术"><a href="#补充技术" class="headerlink" title="补充技术"></a>补充技术</h3><ul><li>引入了环境变量管理，通过<code>.env</code>文件区分不同环境的配置。</li><li>利用Vite的插件系统，如<code>@vitejs/plugin-vue</code>和<code>@vitejs/plugin-components</code>，增强了项目的功能。</li></ul><p>通过本研究，我们提供了一个全面的Vue 3项目脚手架创建指南，涵盖了从项目初始化到部署的全流程，为前端开发者提供了一个高效、现代化的项目起点。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3脚手架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3的概述和入门浅析</title>
      <link href="/2024/09/19/Vue3%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"/>
      <url>/2024/09/19/Vue3%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Vue3作为Vue.js的最新版本，自2020年9月正式发布以来，在前端开发领域引起了广泛关注。它不仅在性能上进行了显著提升，还在开发体验和功能上带来了诸多新特性。以下是对Vue3的详细深度解析，包括与Vue2的对比、Vue3的新特性、Vue3的原理以及Vue3的各种知识点整理。</p><hr><h2 id="一、Vue-3-vs-Vue-2：主要区别"><a href="#一、Vue-3-vs-Vue-2：主要区别" class="headerlink" title="一、Vue 3 vs Vue 2：主要区别"></a>一、Vue 3 vs Vue 2：主要区别</h2><h3 id="1-响应式系统"><a href="#1-响应式系统" class="headerlink" title="1. 响应式系统"></a><strong>1. 响应式系统</strong></h3><ul><li><strong>Vue2</strong>：使用<code>Object.defineProperty</code>来实现响应式系统，这种方式对数组和新增属性的观测不够友好，需要额外的代码来实现。</li><li><strong>Vue3</strong>：采用ES6的<code>Proxy</code> API，能够拦截对象属性的读取、设置、枚举、函数调用等操作，从而实现对整个对象（包括数组）的响应式观测。这种方式不仅提高了性能，还能更精确地捕获数据变化。</li></ul><h3 id="2-组件定义"><a href="#2-组件定义" class="headerlink" title="2. 组件定义"></a><strong>2. 组件定义</strong></h3><ul><li><strong>Vue2</strong>：组件的逻辑（如数据、方法）主要通过<code>data</code>、<code>methods</code>等选项来组织。</li><li><strong>Vue3</strong>：引入了<code>setup</code>函数作为组件逻辑的入口点，并引入了<code>Composition API</code>（组合式API），允许以函数的方式组织组件逻辑，提高了代码的可复用性和可维护性。</li></ul><h3 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3. 性能优化"></a><strong>3. 性能优化</strong></h3><ul><li><strong>Vue3</strong>：通过改进虚拟DOM算法、引入静态提升（Static Nodes Hoisting）和基于模块的编译优化，提供了更高的渲染速度和更小的包大小。此外，Vue3还支持Tree-shaking，可以去除未使用的代码，进一步减小包体积。</li></ul><h2 id="二、Vue3的新特性"><a href="#二、Vue3的新特性" class="headerlink" title="二、Vue3的新特性"></a>二、Vue3的新特性</h2><h3 id="1-Composition-API"><a href="#1-Composition-API" class="headerlink" title="1. Composition API"></a><strong>1. Composition API</strong></h3><ul><li>提供了<code>ref</code>、<code>reactive</code>、<code>computed</code>、<code>watch</code>、<code>watchEffect</code>等函数，允许以函数的方式组织和复用逻辑。</li><li>引入了<code>setup</code>函数，作为组件的初始化配置入口点。</li></ul><h3 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2. Teleport"></a><strong>2. Teleport</strong></h3><ul><li>允许将组件渲染到DOM中的任何位置，而不是默认的组件层级结构中。这对于处理跨组件层级的弹出窗口、对话框等场景非常有用。</li></ul><h3 id="3-Fragments"><a href="#3-Fragments" class="headerlink" title="3. Fragments"></a><strong>3. Fragments</strong></h3><ul><li>Vue3允许组件有多个根节点，内部会将多个标签包含在Fragment虚拟元素中，无需再像Vue2那样使用一个额外的元素包裹。</li></ul><h3 id="4-Suspense"><a href="#4-Suspense" class="headerlink" title="4. Suspense"></a><strong>4. Suspense</strong></h3><ul><li>用于处理异步组件的加载状态，可以在异步组件加载时显示占位符内容，提高用户体验。</li></ul><h3 id="5-更好的TypeScript支持"><a href="#5-更好的TypeScript支持" class="headerlink" title="5. 更好的TypeScript支持"></a><strong>5. 更好的TypeScript支持</strong></h3><ul><li>Vue3提供了更准确的类型推断和类型检查，使得在Vue应用程序中使用TypeScript变得更加流畅和安全。</li></ul><h3 id="6-静态提升"><a href="#6-静态提升" class="headerlink" title="6. 静态提升"></a><strong>6. 静态提升</strong></h3><ul><li>在编译阶段将静态节点提升，以减少运行时的渲染时间和内存占用。</li></ul><h3 id="7-Tree-shaking"><a href="#7-Tree-shaking" class="headerlink" title="7. Tree-shaking"></a><strong>7. Tree-shaking</strong></h3><ul><li>通过现代打包工具（如Webpack、Vite等）的支持，Vue3可以去除未使用的代码，减小最终打包文件的体积。</li></ul><h2 id="三、Vue3的原理"><a href="#三、Vue3的原理" class="headerlink" title="三、Vue3的原理"></a>三、Vue3的原理</h2><h3 id="1-响应式系统-1"><a href="#1-响应式系统-1" class="headerlink" title="1. 响应式系统"></a><strong>1. 响应式系统</strong></h3><ul><li>Vue3的响应式系统基于<code>Proxy</code>和<code>Reflect</code>实现。通过<code>Proxy</code>代理对象，拦截对象的各种操作，并在需要时触发视图更新。同时，<code>reactive</code>函数用于包装响应式数据，通过<code>WeakMap</code>对象实现原始对象和响应式对象之间的映射。</li></ul><h3 id="2-组件系统"><a href="#2-组件系统" class="headerlink" title="2. 组件系统"></a><strong>2. 组件系统</strong></h3><ul><li>Vue3采用虚拟DOM技术来优化渲染性能。在渲染时，Vue3会将组件渲染成虚拟DOM树，并与旧的虚拟DOM树进行对比，只更新需要变化的部分。</li></ul><h3 id="3-编译器"><a href="#3-编译器" class="headerlink" title="3. 编译器"></a><strong>3. 编译器</strong></h3><ul><li>Vue3引入了一个新的编译器，将模板编译成可执行的JavaScript代码。这个编译器具有更高的性能和更好的错误提示能力。</li></ul><h2 id="四、Vue-3-知识点整理"><a href="#四、Vue-3-知识点整理" class="headerlink" title="四、Vue 3 知识点整理"></a>四、Vue 3 知识点整理</h2><h3 id="1-Composition-API-1"><a href="#1-Composition-API-1" class="headerlink" title="1. Composition API"></a><strong>1. Composition API</strong></h3><ul><li><strong>ref</strong>：用于定义基本数据类型的响应式变量。</li><li><strong>reactive</strong>：用于定义对象或数组的响应式数据。</li><li><strong>computed</strong>：用于定义计算属性，基于其他响应式变量进行计算。</li><li><strong>watch</strong>：用于监听响应式变量的变化，并执行回调函数。</li><li><strong>watchEffect</strong>：自动跟踪其回调函数内使用的响应式变量，并在它们变化时重新运行回调函数。</li></ul><h3 id="2-Teleport-1"><a href="#2-Teleport-1" class="headerlink" title="2. Teleport"></a><strong>2. Teleport</strong></h3><ul><li>使用<code>&lt;teleport&gt;</code>标签和<code>to</code>属性来指定渲染目标位置。</li></ul><h3 id="3-Fragments-1"><a href="#3-Fragments-1" class="headerlink" title="3. Fragments"></a><strong>3. Fragments</strong></h3><ul><li>Vue3组件可以包含多个根节点，无需额外包裹元素。</li></ul><h3 id="4-Suspense-1"><a href="#4-Suspense-1" class="headerlink" title="4. Suspense"></a><strong>4. Suspense</strong></h3><ul><li>使用<code>&lt;suspense&gt;</code>标签包裹异步组件和占位符内容。</li></ul><h3 id="5-TypeScript支持"><a href="#5-TypeScript支持" class="headerlink" title="5. TypeScript支持"></a><strong>5. TypeScript支持</strong></h3><ul><li>Vue3提供了更准确的类型定义和类型检查支持，使TypeScript在Vue项目中的使用更加流畅。</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Vue3作为Vue.js的下一代版本，在性能、开发体验和功能上带来了显著提升。通过引入Proxy实现的响应式系统、Composition API、Teleport、Fragments、Suspense等新特性，Vue3不仅提高了渲染性能和开发灵活性，还增强了TypeScript的支持和静态优化能力。这些改进使得Vue3成为构建高效、可维护前端应用的强大工具。简而言之，Vue3以其先进的特性和优化的性能，引领着前端开发的新潮流。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript数据类型解析</title>
      <link href="/2024/09/19/TypeScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90/"/>
      <url>/2024/09/19/TypeScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TypeScript 是一种静态类型的超集语言，扩展了 JavaScript 的功能。它提供了丰富的数据类型，包括基本数据类型和复杂数据类型。下面是对这些类型的详细解析和一些经典例子。</p><hr><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ol><li><strong>布尔类型（Boolean）</strong></li></ol><p>   - 表示逻辑值，只能是<code>true</code>或<code>false</code>。</p><p>   - 示例：<code>let isDone: boolean = false;</code></p><ol start="2"><li><strong>数字类型（Number）</strong></li></ol><p>   - 用于表示数值，可以是整数或浮点数。</p><p>   - TypeScript支持十进制、二进制、八进制和十六进制字面量。</p><p>   - 示例：<code>let count: number = 10; let price: number = 3.99;</code></p><ol start="3"><li><strong>字符串类型（String）</strong></li></ol><p>   - 用于表示文本数据。</p><p>   - 可以使用双引号（””）或单引号（’’）表示字符串。</p><p>   - 示例：<code>let message: string = &quot;Hello, TypeScript!&quot;;</code></p><ol start="4"><li><strong>空值（Null 和 Undefined）</strong></li></ol><p>   - <code>null</code>表示没有任何对象值。</p><p>   - <code>undefined</code>表示一个变量被声明了，但没有被赋值。</p><p>   - 示例：<code>let value1: null = null; let value2: undefined = undefined;</code></p><ol start="5"><li><strong>枚举类型（Enum）</strong></li></ol><p>   - 是对JavaScript标准数据类型的一个补充，用于定义一组命名的常量。</p><p>   - 示例：<code>enum Color &#123; Red, Green, Blue &#125; let myColor: Color = Color.Green;</code></p><ol start="6"><li><strong>任意类型（Any）</strong></li></ol><p>   - 当在编程阶段不确定变量的类型时，可以使用<code>any</code>类型。</p><p>   - 示例：<code>let notSure: any = 4; notSure = &quot;maybe a string&quot;; notSure = false;</code></p><ol start="7"><li><strong>空类型（Void）</strong></li></ol><p>   - 表示没有任何类型，一般用于说明函数的返回值不能是<code>undefined</code>和<code>null</code>之外的值。</p><p>   - 示例：<code>function logMessage(): void &#123; console.log(&quot;This is a log message.&quot;); &#125;</code></p><ol start="8"><li><strong>never</strong></li></ol><p>   - 表示位置类型，通常用于错误位置或总是抛出异常的函数。</p><p>   - 例子：&#96;function throwError(message: string): never {</p><p>       throw new Error(message);</p><p>     }&#96;</p><h3 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h3><ol><li><strong>数组</strong> - 表示元素集合，可以是固定类型或多种类型。</li></ol><p>   - 同类型数组：<code>let list: number[] = [1, 2, 3];</code></p><p>   - 泛型数组：<code>let list: Array&lt;number&gt; = [1, 2, 3];</code></p><ol start="2"><li><strong>元组</strong> - 已知元素数量和类型的数组。</li></ol><p>   - 例子：<code>let x: [string, number] = [&quot;hello&quot;, 10];</code></p><ol start="3"><li><strong>枚举</strong> - 一组命名的常数。</li></ol><p>   - 例子：<code>enum Color &#123;Red, Green, Blue&#125; let c: Color = Color.Green;</code></p><ol start="4"><li><strong>对象</strong> - 表示无序的键值对集合。</li></ol><p>   - 例子：&#96;let person &#x3D; {</p><p>       name: “Alice”,</p><p>       age: 21</p><p>     };&#96;</p><ol start="5"><li><strong>类</strong> - 用于创建对象的模板。</li></ol><p>   - 例子：</p><p>     <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">       <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">greeting</span> = message;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">let</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><ol start="6"><li><strong>接口</strong> - 定义了对象的结构，但不实现它。</li></ol><p>   - 例子：</p><p>     <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     <span class="keyword">interface</span> <span class="title class_">Name</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">       <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">greeter</span>(<span class="params">person: Name</span>) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + person.<span class="property">name</span> + <span class="string">&quot;! You are &quot;</span> + person.<span class="property">age</span> + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><ol start="7"><li><strong>函数</strong> - 表示一段可重用的代码。</li></ol><p>   - 例子：</p><p>     <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> x + y;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><ol start="8"><li><strong>泛型</strong> - 允许在创建类、接口或函数时使类型成为参数。</li></ol><p>   - 例子：</p><p>     <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     <span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> arg;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><ol start="9"><li><strong>联合类型</strong> - 表示一个值可以是几种类型之一。</li></ol><p>   - 例子：<code>let value: string | number = &quot;hello&quot;; // 也可以是 value = 42;</code></p><ol start="10"><li><strong>类型别名</strong> - 为类型创建一个新的名称。</li></ol><p>    - 例子：<code>type Name = string; let userName: Name = &quot;TypeScript&quot;;</code></p><ol start="11"><li><strong>字面量类型</strong> - 表示原始值的精确类型。</li></ol><p>    - 例子：<code>let size: &#39;small&#39; | &#39;medium&#39; | &#39;large&#39; = &#39;medium&#39;;</code></p><ol start="12"><li><strong>索引访问签名</strong> - 允许你访问对象的属性，这些属性的键是字符串或数字。</li></ol><p>    - 例子：</p><p>      <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="keyword">interface</span> <span class="title class_">StringArray</span> &#123;</span><br><span class="line"></span><br><span class="line">        [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> <span class="attr">myArray</span>: <span class="title class_">StringArray</span>;</span><br><span class="line"></span><br><span class="line">      myArray = [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Fred&quot;</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><ol start="13"><li><strong>映射类型</strong> - 创建一个新类型，其属性是从现有类型派生的。</li></ol><p>    - 例子：</p><h2 id=""><a href="#" class="headerlink" title="      "></a>      <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="keyword">type</span> <span class="title class_">OptionsFlags</span> = &#123;</span><br><span class="line"></span><br><span class="line">        [K <span class="keyword">in</span> keyof <span class="keyword">typeof</span> <span class="variable constant_">MY_OPTIONS</span>]: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TypeScript通过丰富的数据类型系统，为JavaScript开发提供了更强的类型安全和代码可读性。基本数据类型和复杂数据类型各有其应用场景，开发者可以根据实际需要选择使用。通过上述经典例子的展示，希望能帮助读者更好地理解TypeScript的数据类型系统。</p>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts的类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript概述-TypeScript入门浅析</title>
      <link href="/2024/09/19/TypeScript%E6%A6%82%E8%BF%B0-TypeScript%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"/>
      <url>/2024/09/19/TypeScript%E6%A6%82%E8%BF%B0-TypeScript%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TypeScript（简称TS）是由微软开发的一款开源的编程语言，它是JavaScript的一个超集，为JavaScript添加了类型系统和一些其他特性。以下是TypeScript的详细解析：</p><hr><h1 id="一、TypeScript是什么？"><a href="#一、TypeScript是什么？" class="headerlink" title="一、TypeScript是什么？"></a>一、TypeScript是什么？</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>TypeScript扩展了JavaScript的语法，并添加了类型系统。它可以在任何支持JavaScript的平台中执行，但需要先编译为JavaScript。  </p><h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h2><ul><li><strong>静态类型</strong>：TypeScript在编译时进行类型检查，有助于在编写代码时就发现错误，提高开发效率和代码质量。  </li><li><strong>类型推断</strong>：TypeScript拥有自动的类型推断机制，可以在不显式声明类型的情况下推断出变量的类型。  </li><li><strong>丰富的类型系统</strong>：包括基本类型（如number、string、boolean等）、数组、元组、枚举、接口、类型别名等。  </li><li><strong>支持ES新特性</strong>：TypeScript遵循最新的ECMAScript规范，并添加了一些ES不具备的新特性。</li></ul><h1 id="二、TypeScript的安装与编译"><a href="#二、TypeScript的安装与编译" class="headerlink" title="二、TypeScript的安装与编译"></a>二、TypeScript的安装与编译</h1><h2 id="1-安装："><a href="#1-安装：" class="headerlink" title="1. 安装："></a>1. 安装：</h2><p>可以通过npm（Node.js的包管理器）安装TypeScript，命令为<code>npm install -g typescript</code>。</p><h2 id="2-编译："><a href="#2-编译：" class="headerlink" title="2. 编译："></a>2. 编译：</h2><p>使用<code>tsc</code>命令可以将TypeScript文件编译为JavaScript文件。例如，<code>tsc hello.ts</code>会将<code>hello.ts</code>编译为<code>hello.js</code>。</p><h1 id="三、TypeScript的数据类型"><a href="#三、TypeScript的数据类型" class="headerlink" title="三、TypeScript的数据类型"></a>三、TypeScript的数据类型</h1><p>TypeScript的数据类型可以分为两类：基本数据类型和复杂数据类型。  </p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li><p><strong>number</strong>：表示数字，包括整数和浮点数。  </p></li><li><p><strong>string</strong>：表示文本数据。  </p></li><li><p><strong>boolean</strong>：表示逻辑值，<code>true</code>或<code>false</code>。  </p></li><li><p><strong>null</strong>：表示空值，是任何类型的子类型。  </p></li><li><p><strong>undefined</strong>：表示未定义的值，是任何类型的子类型。  </p></li><li><p><strong>symbol</strong>：表示唯一的标识符，通常用于对象的属性名。  </p></li><li><p><strong>void</strong>：表示没有任何类型，常用于函数没有返回值的情况。</p></li><li><p><strong>never</strong>： 表示位置类型，通常用于错误位置或总是抛出异常的函数。</p><h3 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h3></li><li><p><strong>数组</strong>：表示一组有序的值，可以使用<code>number[]</code>或<code>Array&lt;number&gt;</code>等语法来声明。  </p></li><li><p><strong>元组</strong>：表示一个已知元素数量和类型的数组，各元素的类型不必相同。  </p></li><li><p><strong>枚举</strong>：表示一组命名的常量，用于定义变量的取值范围。  </p></li><li><p><strong>对象</strong>：表示键值对的集合，可以包含任意类型的值。  </p></li><li><p><strong>接口</strong>：定义对象的形状，包括对象的属性和方法。  </p></li><li><p><strong>类</strong>：用于创建对象的模板。</p></li><li><p><strong>函数</strong>：表示一段可重用的代码。</p></li><li><p><strong>泛型</strong>：允许在创建类、接口或函数时使类型成为参数。</p></li><li><p><strong>类型别名</strong>：为复杂的类型提供一个简短的名称，方便复用。</p></li><li><p><strong>联合类型</strong>：表示一个值可以是几种类型之一。</p></li><li><p><strong>字面量类型</strong>：表示原始值的精确类型。</p></li><li><p><strong>索引访问签名</strong>：允许你访问对象的属性，这些属性的键是字符串或数字。</p></li><li><p><strong>映射类型</strong>：创建一个新类型，其属性是从现有类型派生的。</p></li></ul><h2 id="四、TypeScript的特性"><a href="#四、TypeScript的特性" class="headerlink" title="四、TypeScript的特性"></a>四、TypeScript的特性</h2><ul><li><strong>类型断言</strong>：当TypeScript编译器无法自动推断出变量的类型时，可以使用类型断言来手动指定变量的类型。  </li><li><strong>类型推论</strong>：TypeScript会根据变量的值或上下文来自动推断出变量的类型。  </li><li><strong>泛型</strong>：允许在创建组件时定义一些可变部分，以便在不牺牲类型安全的情况下复用代码。  </li><li><strong>命名空间</strong>：用于组织代码，避免命名冲突。  </li><li><strong>模块</strong>：用于将代码分割成可重用的单元，并在需要时导入。</li></ul><h2 id="五、TypeScript的应用场景"><a href="#五、TypeScript的应用场景" class="headerlink" title="五、TypeScript的应用场景"></a>五、TypeScript的应用场景</h2><p>TypeScript广泛应用于大型项目的开发中，特别是在需要高度类型安全和代码重构能力的场景下。它已被许多知名项目采用，如Angular、Vue、React等前端框架，以及Node.js后端框架如NestJS和Midway等。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TypeScript通过为JavaScript添加类型系统和其他特性，提高了代码的可读性、可维护性和开发效率。它已成为前端开发中的重要工具之一，特别是在构建大型企业级应用时。</p>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript装饰器浅析</title>
      <link href="/2024/09/19/TypeScript%E8%A3%85%E9%A5%B0%E5%99%A8%E6%B5%85%E6%9E%90/"/>
      <url>/2024/09/19/TypeScript%E8%A3%85%E9%A5%B0%E5%99%A8%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TypeScript中的装饰器（Decorator）是一种特殊类型的声明，可以附加到类声明、方法、访问器、属性或参数上，以实现对类及其成员的扩展或修改。装饰器在TypeScript中提供了一种元编程的方式，允许开发者在不修改原有类代码的情况下，动态地添加功能或修改行为。以下是TypeScript装饰器的详细解析：</p><h1 id="一、装饰器的类型"><a href="#一、装饰器的类型" class="headerlink" title="一、装饰器的类型"></a>一、装饰器的类型</h1><p>TypeScript装饰器主要可以分为以下几类：</p><ol><li><strong>类装饰器</strong>：应用于类构造函数，可以用来修改类的行为或元数据。类装饰器接收一个参数，即类的构造函数。</li><li><strong>方法装饰器</strong>：应用于类的方法，可以用来修改方法的行为或元数据。方法装饰器接收三个参数：目标对象、方法名和属性描述符。</li><li><strong>属性装饰器</strong>：应用于类的属性，可以用来修改属性的行为或元数据。属性装饰器接收两个参数：目标对象和属性名。</li><li><strong>参数装饰器</strong>：应用于函数（包括类方法）的参数，可以用来修改函数参数的行为或元数据。参数装饰器接收三个参数：目标对象、方法名和参数索引。</li><li><strong>访问器装饰器</strong>：应用于类的访问器（get和set方法），用于修改访问器的行为。访问器装饰器的使用方式与方法装饰器类似。</li></ol><h1 id="二、装饰器的使用"><a href="#二、装饰器的使用" class="headerlink" title="二、装饰器的使用"></a>二、装饰器的使用</h1><p>要使用TypeScript装饰器，首先需要在<code>tsconfig.json</code>文件中启用<code>experimentalDecorators</code>编译选项，如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ES5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="三、装饰器的示例"><a href="#三、装饰器的示例" class="headerlink" title="三、装饰器的示例"></a>三、装饰器的示例</h1><h2 id="1-类装饰器示例"><a href="#1-类装饰器示例" class="headerlink" title="1. 类装饰器示例"></a>1. 类装饰器示例</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">LogClass</span>(<span class="params">target: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`New instance of <span class="subst">$&#123;target.name&#125;</span> class created.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LogClass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is MyClass constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 控制台输出：New instance of MyClass class created.</span></span><br><span class="line">                                <span class="comment">// This is MyClass constructor</span></span><br></pre></td></tr></table></figure><h2 id="2-方法装饰器示例"><a href="#2-方法装饰器示例" class="headerlink" title="2. 方法装饰器示例"></a>2. 方法装饰器示例</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">LogMethod</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Method <span class="subst">$&#123;propertyKey&#125;</span> of class <span class="subst">$&#123;target.constructor.name&#125;</span> is called.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="meta">@LogMethod</span></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is myMethod&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">instance.<span class="title function_">myMethod</span>(); <span class="comment">// 控制台输出：Method myMethod of class MyClass is called.</span></span><br><span class="line">                     <span class="comment">// This is myMethod</span></span><br></pre></td></tr></table></figure><h2 id="3-属性装饰器示例"><a href="#3-属性装饰器示例" class="headerlink" title="3. 属性装饰器示例"></a>3. 属性装饰器示例</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ReadOnly</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = target[key];</span><br><span class="line">  <span class="keyword">const</span> getter = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> setter = <span class="keyword">function</span>(<span class="params">newValue: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Cannot set readonly property: <span class="subst">$&#123;key&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: getter,</span><br><span class="line">    <span class="attr">set</span>: setter,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="meta">@ReadOnly</span> <span class="keyword">readonly</span> <span class="attr">myProperty</span>: <span class="built_in">string</span> = <span class="string">&#x27;readonly value&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">myProperty</span>); <span class="comment">// 输出：readonly value</span></span><br><span class="line">instance.<span class="property">myProperty</span> = <span class="string">&#x27;new value&#x27;</span>; <span class="comment">// 控制台输出：Cannot set readonly property: myProperty</span></span><br></pre></td></tr></table></figure><h2 id="4-参数装饰器示例"><a href="#4-参数装饰器示例" class="headerlink" title="4. 参数装饰器示例"></a>4. 参数装饰器示例</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">LogParameter</span>(<span class="params">target: <span class="built_in">Object</span>, key: <span class="built_in">string</span>, index: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Parameter Decorator: <span class="subst">$&#123;key&#125;</span>, index: <span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params"><span class="meta">@LogParameter</span> param1: <span class="built_in">string</span>, <span class="meta">@LogParameter</span> param2: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;MyMethod called&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">instance.<span class="title function_">myMethod</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 控制台输出：</span></span><br><span class="line"><span class="comment">// Parameter Decorator: myMethod, index: 0</span></span><br><span class="line"><span class="comment">// Parameter Decorator: myMethod, index: 1</span></span><br><span class="line"><span class="comment">// MyMethod called</span></span><br></pre></td></tr></table></figure><h1 id="四、装饰器的特点"><a href="#四、装饰器的特点" class="headerlink" title="四、装饰器的特点"></a>四、装饰器的特点</h1><ol><li><strong>运行时机</strong>：装饰器在编译阶段执行，而不是在运行时。它们的主要作用是修改类的定义，而不是类的实例。</li><li><strong>元编程</strong>：装饰器提供了一种元编程的方式，允许开发者在不修改原有类代码的情况下，动态地添加功能或修改行为。</li><li><strong>实验性特性</strong>：装饰器在TypeScript中是一种实验性特性，可能会在未来的版本中发生变化。因此，在使用时需要谨慎，</li></ol>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6新特性详解</title>
      <link href="/2024/09/19/ES6%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/09/19/ES6%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-ES6简介与重要新特性概述"><a href="#1-ES6简介与重要新特性概述" class="headerlink" title="1. ES6简介与重要新特性概述"></a>1. ES6简介与重要新特性概述</h1><h2 id="1-1-ECMAScript-6-标准概览"><a href="#1-1-ECMAScript-6-标准概览" class="headerlink" title="1.1 ECMAScript 6 标准概览"></a>1.1 ECMAScript 6 标准概览</h2><p>ECMAScript 6，亦称为ES2015，是JavaScript语言的一次重大更新，由ECMA国际组织于2015年正式发布。这一标准的发布旨在让JavaScript语言更加现代化，提供更多的特性以及改进语法，从而满足开发者在构建复杂应用时的需求。</p><h2 id="1-2-语言与特性的改进点"><a href="#1-2-语言与特性的改进点" class="headerlink" title="1.2 语言与特性的改进点"></a>1.2 语言与特性的改进点</h2><p>ES6引入了一系列新特性，极大地丰富了JavaScript的编程范式，并提升了代码的可读性与可维护性。以下是一些重要的改进点：</p><ul><li><strong>let和const关键字</strong>：引入了块级作用域的变量声明方式，<code>let</code>用于可重新赋值的变量，而<code>const</code>用于声明常量，避免了变量提升的问题。</li><li><strong>模板字符串</strong>：使用反引号（<code>`</code>）和<code>$&#123;&#125;</code>来嵌入表达式，简化了字符串的拼接操作，并且支持多行字符串。</li><li><strong>箭头函数</strong>：提供了更简洁的函数书写方式，并且没有自己的<code>this</code>上下文，通常用于回调函数。</li><li><strong>解构赋值</strong>：允许从数组或对象中快速提取值并分配给变量，简化了数据的交换和属性的提取。</li><li><strong>默认参数值</strong>：允许在函数定义时为参数提供默认值，使得函数调用更为灵活。</li><li><strong>扩展运算符（Spread Operator）</strong>：用于将数组或对象的元素展开到新的数组或对象中，简化了数组和对象的操作。</li><li><strong>类（Class）</strong>：虽然JavaScript是基于原型的语言，但ES6的类语法为面向对象的编程提供了更为清晰和结构化的方式。</li><li><strong>模块化（Modules）</strong>：原生支持模块的导入（<code>import</code>）和导出（<code>export</code>），促进了代码的模块化和重用。</li><li><strong>Promise对象</strong>：为异步编程提供了一种更加优雅和强大的处理方式，避免了回调地狱问题。</li><li><strong>Symbol类型</strong>：引入了一种新的原始数据类型，Symbol值是唯一的，常用于对象属性的键。</li><li><strong>Map和Set数据结构</strong>：提供了新的数据结构，Map类似于对象，但可以有更复杂的键类型；Set用于存储唯一的值。</li><li><strong>迭代器（Iterator）和生成器（Generator）</strong>：提供了一种遍历器接口，允许对数据集合进行更细粒度的遍历控制，而生成器允许你以懒加载的方式生成数据。</li><li><strong>Proxy和Reflect API</strong>：提供了对对象的代理机制和反射操作，使得开发者可以自定义对象的行为。</li><li><strong>新的数组和对象的方法</strong>：如<code>Array.from()</code>, <code>Array.of()</code>, <code>Object.assign()</code>, <code>Object.is()</code>等，这些方法提供了更多的数组和对象操作能力。</li></ul><p>这些新特性共同构成了ES6的强大功能，为JavaScript开发者提供了更多的工具和语法糖，使得编写复杂应用变得更加容易。随着现代浏览器和JavaScript引擎对ES6的广泛支持，这些特性已经被广泛应用在实际开发中。</p><h1 id="2-变量声明与作用域"><a href="#2-变量声明与作用域" class="headerlink" title="2. 变量声明与作用域"></a>2. 变量声明与作用域</h1><h2 id="2-1-let-和-const-声明关键字"><a href="#2-1-let-和-const-声明关键字" class="headerlink" title="2.1 let 和 const 声明关键字"></a>2.1 let 和 const 声明关键字</h2><p>ES6 引入了两个新的关键字 <code>let</code> 和 <code>const</code>，用以改善变量的声明方式。</p><ul><li><code>let</code> 允许开发者声明一个只在特定代码块中存在的变量，这意味着它拥有所谓的块级作用域。与 <code>var</code> 相比，<code>let</code> 没有变量提升的问题，即变量声明不会被提升到它所在代码块的顶部。这减少了因变量提升带来的作用域混乱和意外错误。</li><li><code>const</code> 用于声明一个只读的常量，一旦声明并赋予初值后，其值不能被重新赋值。这有助于防止在代码中意外修改该值。<code>const</code> 同样具有块级作用域和无变量提升的特性。</li></ul><h2 id="2-2-块级作用域与变量提升"><a href="#2-2-块级作用域与变量提升" class="headerlink" title="2.2 块级作用域与变量提升"></a>2.2 块级作用域与变量提升</h2><p>块级作用域是指变量的作用域仅限于声明它的代码块（例如，一个 <code>for</code> 循环或 <code>if</code> 语句）内。这个特性减少了变量污染全局作用域的风险，并使得代码更加清晰和可预测。</p><p>变量提升是 JavaScript 中一个长期存在的问题，其中使用 <code>var</code> 声明的变量会被视为在它们声明的函数或全局作用域的顶部进行声明。这意味着在变量声明之前访问这些变量，将返回 <code>undefined</code> 而不是报错。</p><p>ES6 通过引入 <code>let</code> 和 <code>const</code> 声明关键字，改变了这一行为。使用这些关键字声明的变量不会被提升，如果尝试在声明之前访问这些变量，JavaScript 引擎将抛出一个 <code>ReferenceError</code> 错误。</p><p>此外，<code>let</code> 和 <code>const</code> 声明的变量存在一个被称为“死区”（Temporal Dead Zone, TDZ）的时间段，从代码块开始到变量声明为止的区域。在这个时间段内，如果尝试访问变量，将导致运行时错误。这一特性进一步增强了代码的安全性和可预测性。</p><h1 id="3-解构赋值与展开语法"><a href="#3-解构赋值与展开语法" class="headerlink" title="3. 解构赋值与展开语法"></a>3. 解构赋值与展开语法</h1><h2 id="3-1-解构赋值的使用场景"><a href="#3-1-解构赋值的使用场景" class="headerlink" title="3.1 解构赋值的使用场景"></a>3.1 解构赋值的使用场景</h2><p>解构赋值是ES6引入的一种语法糖，允许我们通过数组或对象的结构来直接提取数据赋值给变量。这种特性在处理复杂的数据结构时非常有用，例如从API响应中提取数据或在函数参数中使用。</p><ul><li><p><strong>数组解构</strong>：当处理返回多个值的数组时，可以直接将返回的数组元素赋值给定义好的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>对象解构</strong>：在对象中，可以通过变量名来直接获取对象的属性值，使得赋值更加直观和简洁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age); <span class="comment">// Alice 25</span></span><br></pre></td></tr></table></figure></li><li><p><strong>默认值解构</strong>：在解构时，可以为变量指定默认值，当源数据中缺少相应的值时，变量会使用默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; x = <span class="number">10</span>, y = <span class="number">20</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">5</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y); <span class="comment">// 5 20</span></span><br></pre></td></tr></table></figure></li><li><p><strong>嵌套结构解构</strong>：解构赋值支持嵌套的对象或数组，使得可以从嵌套结构中方便地提取深层的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">user</span>: &#123; name, age &#125; &#125; = &#123; <span class="attr">user</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125; &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age); <span class="comment">// Bob 30</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-展开语法的操作与应用"><a href="#3-2-展开语法的操作与应用" class="headerlink" title="3.2 展开语法的操作与应用"></a>3.2 展开语法的操作与应用</h2><p>展开语法（Spread syntax）使用三个点（<code>...</code>）来表示可迭代对象的迭代，或者将对象的属性展开成单独的参数或属性。</p><ul><li><p><strong>数组的展开</strong>：在函数调用或者数组字面量中使用展开语法，可以将数组的元素作为独立的元素处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> moreNumbers = [...numbers, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(moreNumbers); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>对象的展开</strong>：在对象字面量中使用展开语法，可以复制一个对象的所有可枚举属性到新对象中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Carol&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> newPerson = &#123; ...person, <span class="attr">age</span>: <span class="number">23</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newPerson); <span class="comment">// &#123; name: &#x27;Carol&#x27;, age: 23 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>函数参数的展开</strong>：在函数调用时使用展开语法，可以将数组或对象中的元素或属性作为独立的参数传递。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> params = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(...params)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></li><li><p><strong>混合使用解构和展开</strong>：解构和展开可以结合使用，实现更加灵活的数据操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [firstName, ...restOfName] = <span class="string">&#x27;Charlotte&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstName, restOfName); <span class="comment">// &#x27;C&#x27; [&#x27;h&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;t&#x27;, &#x27;t&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在函数中使用展开来接受任意数量的参数</strong>：使用展开语法，函数可以接收不定数量的参数，并将它们作为数组处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">applyOperations</span>(<span class="params">...operations</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> operations.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, operation</span>) =&gt;</span> <span class="title function_">operation</span>(acc), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">applyOperations</span>(<span class="title class_">Math</span>.<span class="property">pow</span>, <span class="number">2</span>)(<span class="number">10</span>)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><h1 id="4-箭头函数与函数默认参数"><a href="#4-箭头函数与函数默认参数" class="headerlink" title="4. 箭头函数与函数默认参数"></a>4. 箭头函数与函数默认参数</h1></li></ul><h2 id="4-1-箭头函数"><a href="#4-1-箭头函数" class="headerlink" title="4.1 箭头函数"></a>4.1 箭头函数</h2><p>箭头函数是ES6引入的一种新的函数书写方式，它提供了更加简洁的函数定义语法，并且没有自身的<code>this</code>、<code>arguments</code>、<code>super</code>或<code>new.target</code>。箭头函数的特点是：</p><ul><li>语法简洁：箭头函数没有<code>function</code>关键字，也没有函数名（匿名），使用<code>=&gt;</code>定义。</li><li>没有独立的<code>this</code>：箭头函数内的<code>this</code>值与其上下文相同，不会像传统函数那样创建新的<code>this</code>上下文。</li><li>不可用作构造函数：不可以使用<code>new</code>关键字来实例化箭头函数。</li><li>不绑定<code>arguments</code>：不能使用<code>arguments</code>对象，应该使用剩余参数(<code>...args</code>)来获取函数参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：基本的箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = (<span class="params">x, y</span>) =&gt; x * y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：没有参数或者单一参数时，可以省略括号</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sayHello</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：箭头函数使用this上下文</span></span><br><span class="line"><span class="keyword">const</span> button = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Submit&#x27;</span>,</span><br><span class="line">  <span class="attr">handleClick</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)  <span class="comment">// this引用的是button对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2-函数默认参数"><a href="#4-2-函数默认参数" class="headerlink" title="4.2 函数默认参数"></a>4.2 函数默认参数</h2><p>函数默认参数是ES6引入的一个特性，允许在定义函数时为参数指定默认值。当函数被调用时，如果没有为该参数传递值，则会使用默认值。这个特性可以减少对<code>undefined</code>值的检查，简化代码。</p><ul><li>默认参数必须在参数列表的最后：只有未传入的参数才能有默认值，如果参数在调用时未提供，则使用默认值。</li><li>默认参数可以引用之前的参数：这可以用来创建累积参数或者默认对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：基本的默认参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name, message = <span class="string">&#x27;Hello&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;message&#125;</span>, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：未传入name参数时，使用默认值</span></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;World&#x27;</span>);  <span class="comment">// &quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：使用参数默认值引用前面的参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">value, ...args</span>) &#123;</span><br><span class="line">  args.<span class="title function_">unshift</span>(value);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Info:&#x27;</span>, <span class="string">&#x27;This is a default parameter demo&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在实际开发中，箭头函数与函数默认参数常被结合使用，来创建更加简洁、易于理解的代码结构。默认参数可以为函数提供灵活性，而箭头函数可以减少关于<code>this</code>的误解。这两者的结合使得JavaScript的函数式编程更加强大和高效。</p><h1 id="5-模板字符串与多行字符串"><a href="#5-模板字符串与多行字符串" class="headerlink" title="5. 模板字符串与多行字符串"></a>5. 模板字符串与多行字符串</h1><p>模板字符串是ECMAScript 6 (ES6) 引入的一项新特性，它提高了字符串处理的灵活性和表达能力。与传统的字符串连接相比，模板字符串具备以下显著优势：</p><h2 id="5-1-模板字符串的使用方法"><a href="#5-1-模板字符串的使用方法" class="headerlink" title="5.1 模板字符串的使用方法"></a>5.1 模板字符串的使用方法</h2><p>模板字符串使用反引号 <code>`</code> 包围，支持在字符串中嵌入变量和表达式，通过 <code>$&#123;expression&#125;</code> 的形式进行插入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> greeting = <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，变量 <code>name</code> 的值被嵌入到字符串中，这比传统的字符串连接方法更简洁、易读。</p><h2 id="5-2-多行字符串的实现"><a href="#5-2-多行字符串的实现" class="headerlink" title="5.2 多行字符串的实现"></a>5.2 多行字符串的实现</h2><p>模板字符串同时解决了多行字符串的编写问题。在传统JavaScript中，多行字符串需要使用转义字符 <code>\</code> 或者通过数组的 <code>join</code> 方法来实现。而模板字符串允许字符串自然地跨越多行，无需额外的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiLineString = <span class="string">`</span></span><br><span class="line"><span class="string">  First line</span></span><br><span class="line"><span class="string">  Second line</span></span><br><span class="line"><span class="string">  Third line</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><h2 id="5-3-字符串插值的高级用法"><a href="#5-3-字符串插值的高级用法" class="headerlink" title="5.3 字符串插值的高级用法"></a>5.3 字符串插值的高级用法</h2><p>模板字符串不仅可以用来插值变量，还可以嵌入更复杂的表达式，如函数调用、算术运算等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">`The sum of <span class="subst">$&#123;a&#125;</span> and <span class="subst">$&#123;b&#125;</span> is <span class="subst">$&#123;a + b&#125;</span>.`</span>;</span><br></pre></td></tr></table></figure><h2 id="5-4-模板字符串与标签模板函数"><a href="#5-4-模板字符串与标签模板函数" class="headerlink" title="5.4 模板字符串与标签模板函数"></a>5.4 模板字符串与标签模板函数</h2><p>ES6还引入了标签模板函数，它允许开发者定义如何处理模板字符串中的插值表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">strings, ...values</span>) &#123;</span><br><span class="line">  <span class="comment">// strings是一个数组，包含静态的字符串片段</span></span><br><span class="line">  <span class="comment">// values是一个数组，包含传入的插值表达式求值后的结果</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(strings); <span class="comment">// [&quot;Hello &quot;, &quot;!&quot;]</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(values);  <span class="comment">// [&quot;World&quot;]</span></span><br><span class="line">  <span class="keyword">return</span> strings.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, str, i</span>) =&gt;</span> acc + (values[i] || <span class="string">&#x27;&#x27;</span>) + str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> taggedString = tag<span class="string">`Hello <span class="subst">$&#123;<span class="string">&#x27;World&#x27;</span>&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure><p>模板字符串和多行字符串的加入，极大地丰富了JavaScript在字符串处理方面的表现力，使得代码更加简洁和易于维护。</p><h1 id="6-Promise对象与异步编程"><a href="#6-Promise对象与异步编程" class="headerlink" title="6. Promise对象与异步编程"></a>6. Promise对象与异步编程</h1><p>Promise对象是ES6中引入的一个非常重要的概念，它代表了异步操作的最终完成或失败，使得异步编程更加直观、易用和易于管理。</p><h2 id="6-1-Promise基础"><a href="#6-1-Promise基础" class="headerlink" title="6.1 Promise基础"></a>6.1 Promise基础</h2><p>Promise是一个构造函数，用来生成一个Promise实例。每个实例代表一个异步操作的最终完成（或失败）及其结果值。</p><ul><li><strong>状态</strong>: Promise对象有两个状态，分别是<code>pending</code>（进行中），<code>fulfilled</code>（已成功），或者<code>rejected</code>（已失败）。</li><li><strong>使用场景</strong>: 适用于延迟或异步计算的场景，比如获取用户输入、网络请求等。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 异步操作的逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-2-Promise方法"><a href="#6-2-Promise方法" class="headerlink" title="6.2 Promise方法"></a>6.2 Promise方法</h2><ul><li><strong>.then()</strong>: 用于指定当Promise成功时的回调函数。</li><li><strong>.catch()</strong>: 用于指定当Promise失败时的回调函数。</li><li><strong>.finally()</strong>: 无论Promise成功还是失败，都会执行的回调函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise resolved:&#x27;</span>, value);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise rejected:&#x27;</span>, error);</span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise is settled&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-3-Promise链式调用"><a href="#6-3-Promise链式调用" class="headerlink" title="6.3 Promise链式调用"></a>6.3 Promise链式调用</h2><p>Promise支持链式调用，即可以在一个<code>.then()</code>方法的回调中返回另一个Promise对象，这使得异步操作的序列管理变得简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">asyncOperation1</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">asyncOperation2</span>(result1);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Result of second operation:&#x27;</span>, result2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;An error occurred:&#x27;</span>, error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="6-4-Promise与async-x2F-await"><a href="#6-4-Promise与async-x2F-await" class="headerlink" title="6.4 Promise与async&#x2F;await"></a>6.4 Promise与async&#x2F;await</h2><p>ES2017年引入的<code>async/await</code>语法糖在一定程度上是对Promise的进一步简化，使得异步代码看起来和同步代码类似。</p><ul><li><strong>async</strong>: 定义异步函数，其内部可以正常使用<code>await</code>。</li><li><strong>await</strong>: 暂停函数的执行，等待Promise解决，并返回解决后的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncCall</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">asyncOperation</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Async operation failed:&#x27;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-Promise的应用"><a href="#6-5-Promise的应用" class="headerlink" title="6.5 Promise的应用"></a>6.5 Promise的应用</h2><p>在ES6之前，异步编程的一个主要障碍是所谓的“回调地狱”，Promise通过提供统一的接口来解决这一问题。Promise的引入使得异步编程更加可靠、容易理解和维护。</p><p>在实际应用中，Promise广泛用于各种场景，如：</p><ul><li>网络请求</li><li>文件操作</li><li>定时器</li><li>任何需要异步执行的任务</li></ul><p>Promise对象的引入，为JavaScript的异步编程提供了一种更先进、更强大的工具，极大地简化了异步代码的复杂度，提高了代码的可读性和可维护性。</p><h1 id="7-类与模块化"><a href="#7-类与模块化" class="headerlink" title="7. 类与模块化"></a>7. 类与模块化</h1><h2 id="7-1-类（Classes）"><a href="#7-1-类（Classes）" class="headerlink" title="7.1 类（Classes）"></a>7.1 类（Classes）</h2><p>ES6 引入了类的概念，提供了一种更接近传统面向对象语言的类定义方式，尽管它本质上仍然是基于原型的。类（class）语法是一种语法糖，让对象的创建更清晰、更易于理解。</p><ul><li><strong>定义类</strong>：使用 <code>class</code> 关键字来定义类。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">introduce</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, and I am <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>继承</strong>：使用 <code>extends</code> 关键字实现类的继承。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name, age);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">describe</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">super</span>.introduce()&#125;</span> I am also an employee with job <span class="subst">$&#123;<span class="variable language_">this</span>.job&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>静态方法</strong>：使用 <code>static</code> 关键字定义静态方法，该方法可以在类本身上调用，而不需要实例化类。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MathUtils</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MathUtils</span>.<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="7-2-模块化（Modules）"><a href="#7-2-模块化（Modules）" class="headerlink" title="7.2 模块化（Modules）"></a>7.2 模块化（Modules）</h2><p>ES6 引入了原生的模块系统，使用 <code>import</code> 和 <code>export</code> 关键字来实现模块的导入和导出，从而提高代码的重用性和组织性。</p><ul><li><strong>导出模块</strong>：使用 <code>export</code> 关键字导出模块成员。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mathUtils.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>导入模块</strong>：使用 <code>import</code> 关键字导入其他模块的成员。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add, subtract &#125; <span class="keyword">from</span> <span class="string">&#x27;./mathUtils.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">5</span>, <span class="number">3</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">subtract</span>(<span class="number">5</span>, <span class="number">3</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><strong>默认导出</strong>：每个模块都可以有一个默认导出，使用 <code>default</code> 关键字。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tool.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This is a tool function.&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> tool <span class="keyword">from</span> <span class="string">&#x27;./tool.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">tool</span>()); <span class="comment">// &#x27;This is a tool function.&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p>模块化是 ES6 的一个重要特性，它允许开发者将代码封装成独立的模块，然后在需要的地方导入使用，从而提高了代码的可维护性和可读性。</p><h1 id="8-新的数据结构"><a href="#8-新的数据结构" class="headerlink" title="8. 新的数据结构"></a>8. 新的数据结构</h1><h2 id="8-1-Map-和-Set"><a href="#8-1-Map-和-Set" class="headerlink" title="8.1 Map 和 Set"></a>8.1 Map 和 Set</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>特性：Map 对象保存键值对的集合，其中的键与值可以是任何类型，它支持迭代器，可以记住键的原始插入顺序。</li><li>应用场景：当需要使用非基本数据类型作为键，或者需要保持键的顺序时，Map 显得尤为重要。</li><li>示例：<code>let map = new Map([[&#39;key1&#39;, &#39;value1&#39;], [&#39;key2&#39;, &#39;value2&#39;]])</code></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li>特性：Set 对象允许你存储唯一的值，无论是原始值还是对象引用。</li><li>应用场景：在需要保证集合中元素唯一性的情况下，Set 提供了一个非常有用的结构。</li><li>示例：<code>let set = new Set([1, 2, 3, 5, 5]); // 元素5只会出现一次</code></li></ul><h2 id="8-2-迭代器（Iterator）"><a href="#8-2-迭代器（Iterator）" class="headerlink" title="8.2 迭代器（Iterator）"></a>8.2 迭代器（Iterator）</h2><ul><li>特性：迭代器是一种特殊对象，可以让 JavaScript 引擎允许遍历集合对象，如 数组、Map 和 Set。</li><li>应用：通过 for…of 循环，可以使用迭代器遍历集合中的所有元素。</li><li>示例：<code>for (let num of [1, 2, 3]) &#123; console.log(num); &#125;</code></li></ul><h2 id="8-3-可迭代协议（Iterable）"><a href="#8-3-可迭代协议（Iterable）" class="headerlink" title="8.3 可迭代协议（Iterable）"></a>8.3 可迭代协议（Iterable）</h2><ul><li>特性：具有迭代器接口的对象被称为可迭代的，它们返回一个迭代器来遍历自身的元素。</li><li>应用：这使得自定义对象可以与 for…of 循环协同工作。</li><li>示例：<code>[1, 2, 3]</code> 就是可迭代的，因为它可以返回一个迭代器。</li></ul><h2 id="8-4-生成器（Generator）"><a href="#8-4-生成器（Generator）" class="headerlink" title="8.4 生成器（Generator）"></a>8.4 生成器（Generator）</h2><ul><li>特性：生成器是一个特殊的函数，可以返回一个迭代器，但与普通函数不同，生成器函数允许你通过 <code>yield</code> 关键字中断函数执行，并在之后恢复函数的执行。</li><li>应用场景：生成器用于懒加载（按需加载数据），用于实现更复杂的异步流。</li><li>示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">idMaker</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">yield</span> index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="title function_">idMaker</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="8-5-代理（Proxy）"><a href="#8-5-代理（Proxy）" class="headerlink" title="8.5 代理（Proxy）"></a>8.5 代理（Proxy）</h2><ul><li>特性：Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。</li><li>应用场景：Proxy 可以用于验证属性赋值，或者创建一个对象的只读版本。</li><li>示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;type&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;不可以设置 type 属性！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-6-反射（Reflect）"><a href="#8-6-反射（Reflect）" class="headerlink" title="8.6 反射（Reflect）"></a>8.6 反射（Reflect）</h2><ul><li>特性：Reflect 对象提供了拦截 JavaScript 操作的方法，这些方法与 Proxy 相关，用于统一异常处理。</li><li>应用：使用 Reflect 方法可以更安全地执行属性操作，因为它们会返回布尔值，而不是抛出异常。</li><li>示例：<code>console.log(Reflect.set(obj, &#39;property1&#39;, 123)); // true</code><h1 id="9-其他语言特性"><a href="#9-其他语言特性" class="headerlink" title="9. 其他语言特性"></a>9. 其他语言特性</h1></li></ul><p>ES6 作为 JavaScript 语言的一次重大更新，引入了许多新的语言特性，除了之前提到的 let 和 const、箭头函数、模板字符串、解构赋值、Promise、类、模块化等特性之外，还有一些其他的新特性，它们同样对语言的发展产生了深远的影响：</p><h2 id="9-1-扩展运算符（Spread-Operator）"><a href="#9-1-扩展运算符（Spread-Operator）" class="headerlink" title="9.1 扩展运算符（Spread Operator）"></a>9.1 扩展运算符（Spread Operator）</h2><p>ES6 引入了扩展运算符 <code>...</code>，它可以用于数组和对象的复制、合并等操作，提供了一种更简洁的方式来展开集合类型的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组合并</span></span><br><span class="line"><span class="keyword">const</span> firstArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> secondArray = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> combinedArray = [...firstArray, ...secondArray];</span><br><span class="line"><span class="comment">// 结果: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象合并</span></span><br><span class="line"><span class="keyword">const</span> firstObject = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> secondObject = &#123; <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> combinedObject = &#123; ...firstObject, ...secondObject &#125;;</span><br><span class="line"><span class="comment">// 结果: &#123; a: 1, b: 2, c: 3, d: 4 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="9-2-默认参数值"><a href="#9-2-默认参数值" class="headerlink" title="9.2 默认参数值"></a>9.2 默认参数值</h2><p>函数的参数可以设置默认值，当调用函数时，如果没有传入该参数或者传入了 <code>undefined</code>，则会使用默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name, message = <span class="string">&#x27;Hello&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;message&#125;</span>, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;World&#x27;</span>); <span class="comment">// &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><h2 id="9-3-剩余参数（Rest-Parameters）"><a href="#9-3-剩余参数（Rest-Parameters）" class="headerlink" title="9.3 剩余参数（Rest Parameters）"></a>9.3 剩余参数（Rest Parameters）</h2><p>剩余参数允许我们将一个不确定数量的参数表示为一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...numbers</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, num</span>) =&gt;</span> total + num, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="9-4-箭头函数的进一步讨论"><a href="#9-4-箭头函数的进一步讨论" class="headerlink" title="9.4 箭头函数的进一步讨论"></a>9.4 箭头函数的进一步讨论</h2><p>箭头函数提供了一种更简洁的函数定义方式，并且没有自己的 <code>this</code> 绑定，其 <code>this</code> 值取决于上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> squares = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * num);</span><br></pre></td></tr></table></figure><h2 id="9-5-for…of-循环"><a href="#9-5-for…of-循环" class="headerlink" title="9.5 for…of 循环"></a>9.5 for…of 循环</h2><p><code>for...of</code> 循环允许你遍历可迭代的对象，如数组、字符串等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: a, b, c</span></span><br></pre></td></tr></table></figure><h2 id="9-6-新增的数据类型：Symbol"><a href="#9-6-新增的数据类型：Symbol" class="headerlink" title="9.6 新增的数据类型：Symbol"></a>9.6 新增的数据类型：Symbol</h2><p>ES6 引入了一个新的原始数据类型 <code>Symbol</code>，用于创建唯一的不可变的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;mySymbol&#x27;</span>);</span><br><span class="line"><span class="keyword">typeof</span> mySymbol; <span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure><h2 id="9-7-代理和反射"><a href="#9-7-代理和反射" class="headerlink" title="9.7 代理和反射"></a>9.7 代理和反射</h2><p><code>Proxy</code> 对象用于创建一个对象的代理，从而可以拦截和定义基本操作的自定义行为。<code>Reflect</code> 对象提供了拦截操作的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><h2 id="9-8-Promise"><a href="#9-8-Promise" class="headerlink" title="9.8 Promise"></a>9.8 Promise</h2><p>Promise 对象用于异步计算，它代表了一个可能还不可用的值，或一个在未来某个时间点才可用的最终值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;Hello, World!&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value));</span><br></pre></td></tr></table></figure><h2 id="9-9-模块化"><a href="#9-9-模块化" class="headerlink" title="9.9 模块化"></a>9.9 模块化</h2><p>ES6 引入了模块化的概念，使用 <code>import</code> 和 <code>export</code> 关键字来导入和导出模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="9-10-异步函数（Async-x2F-Await）"><a href="#9-10-异步函数（Async-x2F-Await）" class="headerlink" title="9.10 异步函数（Async&#x2F;Await）"></a>9.10 异步函数（Async&#x2F;Await）</h2><p>ES6 在 <code>Promise</code> 的基础上进一步引入了 <code>async</code> 和 <code>await</code> 关键字，使得异步代码的编写更加直观和简洁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchData</span>();</span><br></pre></td></tr></table></figure><p>ES6 的这些特性极大地丰富了 JavaScript 语言的功能，提升了开发效率和代码质量。</p><h1 id="10-ES6兼容性与实际开发应用"><a href="#10-ES6兼容性与实际开发应用" class="headerlink" title="10. ES6兼容性与实际开发应用"></a>10. ES6兼容性与实际开发应用</h1><h2 id="10-1-浏览器兼容性分析"><a href="#10-1-浏览器兼容性分析" class="headerlink" title="10.1 浏览器兼容性分析"></a>10.1 浏览器兼容性分析</h2><p>ES6作为JavaScript语言的一次大版本更新，带来了诸多新特性，然而这些新特性在不同浏览器中的支持程度存在差异。根据<a href="http://kangax.github.io/compat-table/es6/">Kangax的兼容性表</a>，可以详细了解各个浏览器对ES6特性的支持情况。</p><ul><li>现代浏览器如Chrome、Firefox、Edge对ES6的支持较为全面，但仍有部分特性处于实验性阶段或不被支持。</li><li>旧版浏览器如Internet Explorer对ES6的支持较差，许多新特性无法直接使用。</li></ul><h2 id="10-2-兼容性解决方案"><a href="#10-2-兼容性解决方案" class="headerlink" title="10.2 兼容性解决方案"></a>10.2 兼容性解决方案</h2><p>针对不同浏览器的兼容性问题，开发者通常采取以下方案：</p><ul><li><strong>使用Babel等转译工具</strong>：将ES6代码转换为ES5代码，以确保在旧版浏览器中的兼容性。</li><li><strong>Polyfills</strong>：使用如<code>es6-shim</code>等库来提供ES6特性的兼容性补丁，使旧版浏览器能够模拟ES6的行为。</li></ul><h2 id="10-3-Node-js对ES6的支持"><a href="#10-3-Node-js对ES6的支持" class="headerlink" title="10.3 Node.js对ES6的支持"></a>10.3 Node.js对ES6的支持</h2><p>Node.js在不同版本中对ES6的支持程度也有所不同，开发者可以通过以下方式使用ES6特性：</p><ul><li>使用<code>.mjs</code>后缀的文件，Node.js将默认将其作为ES6模块处理。</li><li>在<code>package.json</code>中设置<code>&quot;type&quot;: &quot;module&quot;</code>，使得<code>.js</code>文件按照ES6模块标准加载。</li></ul><h2 id="10-4-实际开发中的ES6应用"><a href="#10-4-实际开发中的ES6应用" class="headerlink" title="10.4 实际开发中的ES6应用"></a>10.4 实际开发中的ES6应用</h2><p>在实际开发过程中，ES6的新特性得到广泛应用，包括但不限于：</p><ul><li><strong>模块化</strong>：<code>import</code>和<code>export</code>的使用，使得代码更加模块化和易于管理。</li><li><strong>箭头函数</strong>：简化函数的书写，提高代码可读性。</li><li><strong>Promise和Async&#x2F;Await</strong>：改善异步编程模型，使异步代码更易于编写和理解。</li><li><strong>解构赋值</strong>：简化变量的声明和赋值，提高编码效率。</li></ul><h2 id="10-5-开发者建议"><a href="#10-5-开发者建议" class="headerlink" title="10.5 开发者建议"></a>10.5 开发者建议</h2><p>虽然ES6提供了强大的新特性，但在实际开发中，开发者应当注意以下几点：</p><ul><li>根据目标用户的浏览器使用情况，评估是否使用某些ES6特性。</li><li>在项目中统一使用ES6或ES5语法，避免混用导致潜在的兼容性问题。</li><li>利用现代前端构建工具链，如Webpack、Rollup等，自动处理代码的转译和模块化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>饿了么选择器组件el-select怎么在change事件中获取组件的label值</title>
      <link href="/2023/04/11/%E9%A5%BF%E4%BA%86%E4%B9%88%E9%80%89%E6%8B%A9%E5%99%A8%E7%BB%84%E4%BB%B6el-select%E6%80%8E%E4%B9%88%E5%9C%A8change%E4%BA%8B%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%E7%9A%84/"/>
      <url>/2023/04/11/%E9%A5%BF%E4%BA%86%E4%B9%88%E9%80%89%E6%8B%A9%E5%99%A8%E7%BB%84%E4%BB%B6el-select%E6%80%8E%E4%B9%88%E5%9C%A8change%E4%BA%8B%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<ul><li><p>在element-ui的el-select组件中，可以通过$refs来获取到组件实例，然后通过实例的属性来获取选中的label值。</p><p>示例代码：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-select</span> <span class="attr">v-model</span>=<span class="string">&quot;selectedValue&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySelect&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;handleChange&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-option</span> <span class="attr">v-for</span>=<span class="string">&quot;item in options&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.value&quot;</span> <span class="attr">:label</span>=<span class="string">&quot;item.label&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;item.value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">selectedValue</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">options</span>: [</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">value</span>: <span class="string">&#x27;option1&#x27;</span>, <span class="attr">label</span>: <span class="string">&#x27;选项1&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">value</span>: <span class="string">&#x27;option2&#x27;</span>, <span class="attr">label</span>: <span class="string">&#x27;选项2&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">value</span>: <span class="string">&#x27;option3&#x27;</span>, <span class="attr">label</span>: <span class="string">&#x27;选项3&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">      ]</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleChange</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> selectedLabel = <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">mySelect</span>.<span class="property">selectedLabel</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(selectedLabel)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  在el-select组件上添加ref属性，然后在handleChange方法中通过this.$refs.mySelect获取到组件实例，然后通过selectedLabel属性获取到选中的label值。</p><p>  需要注意的是，selectedLabel属性只有在el-select组件的multiple属性为false时才有效。如果multiple属性为true，则需要通过selected属性获取到选中的选项数组，然后遍历数组获取到每个选项的label值。</p>]]></content>
      
      
      <categories>
          
          <category> element-ui </category>
          
      </categories>
      
      
        <tags>
            
            <tag> el-select </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么用js判断dom存不存某class</title>
      <link href="/2023/03/27/%E6%80%8E%E4%B9%88%E7%94%A8js%E5%88%A4%E6%96%ADdom%E5%AD%98%E4%B8%8D%E5%AD%98%E6%9F%90class/"/>
      <url>/2023/03/27/%E6%80%8E%E4%B9%88%E7%94%A8js%E5%88%A4%E6%96%ADdom%E5%AD%98%E4%B8%8D%E5%AD%98%E6%9F%90class/</url>
      
        <content type="html"><![CDATA[<ul><li><p>怎么用js判断 dom存不存某class</p></li><li><p>可以使用JavaScript的<code>classList</code>属性来判断DOM元素是否包含某个class。<code>classList</code>属性返回一个DOMTokenList对象，它包含了元素的所有class，可以使用它的<code>contains()</code>方法来判断元素是否包含某个class。具体步骤如下：</p><ol><li>获取需要判断的DOM元素，例如：</li></ol>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-element&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>classList</code>属性获取元素的class列表，例如：</li></ol>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> classList = element.<span class="property">classList</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用<code>contains()</code>方法判断元素是否包含某个class，例如：</li></ol>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (classList.<span class="title function_">contains</span>(<span class="string">&#x27;my-class&#x27;</span>)) &#123;</span><br><span class="line"> <span class="comment">// 元素包含my-class</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 元素不包含my-class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>classList</code>属性在IE9及以下版本的浏览器中不支持，可以使用<code>className</code>属性来代替。<code>className</code>属性返回元素的class字符串，可以使用<code>indexOf()</code>方法来判断元素是否包含某个class，例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.<span class="property">className</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;my-class&#x27;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 元素包含my-class</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 元素不包含my-class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts_接口</title>
      <link href="/2022/08/22/ts-%E6%8E%A5%E5%8F%A3/"/>
      <url>/2022/08/22/ts-%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>是一种能力，一种约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">IPerson</span>&#123;</span><br><span class="line">        <span class="attr">firstName</span>:<span class="built_in">string</span>,</span><br><span class="line">        <span class="attr">lastName</span>:<span class="built_in">string</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showFullName</span>(<span class="params">person:IPerson</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span>+<span class="string">&#x27;_&#x27;</span>+person.<span class="property">lastName</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> person = &#123;</span><br><span class="line">        <span class="attr">firstName</span>:<span class="string">&#x27;东方&#x27;</span>,</span><br><span class="line">        <span class="attr">lastName</span>:<span class="string">&#x27;不败&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">showFullName</span>(person))</span><br><span class="line">    <span class="comment">// 东方_不败</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。我们使用接口（Interfaces）来定义对象的类型。接口是<code>对象的状态(属性)和行为(方法)的抽象(描述)</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型</span></span><br><span class="line"><span class="comment">接口: 是对象的状态(属性)和行为(方法)的抽象(描述)</span></span><br><span class="line"><span class="comment">接口类型的对象</span></span><br><span class="line"><span class="comment">    多了或者少了属性是不允许的</span></span><br><span class="line"><span class="comment">    可选属性: ?</span></span><br><span class="line"><span class="comment">    只读属性: readonly</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">需求: 创建人的对象, 需要对人的属性进行一定的约束</span></span><br><span class="line"><span class="comment">  id是number类型, 必须有, 只读的</span></span><br><span class="line"><span class="comment">  name是string类型, 必须有</span></span><br><span class="line"><span class="comment">  age是number类型, 必须有</span></span><br><span class="line"><span class="comment">  sex是string类型, 可以没有</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 定义人的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person1</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型检查器会查看对象内部的属性是否与IPerson接口描述一致, 如果不一致就会提示类型错误。</span></span><br></pre></td></tr></table></figure><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。<br>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号。<br>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  sex?: <span class="built_in">string</span> <span class="comment">//可选地</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person2</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="comment">// sex: &#x27;男&#x27; // 可以没有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly 来指定只读属性:<br>一旦赋值后再也不能被改变了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  sex?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">person2</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="comment">// sex: &#x27;男&#x27; // 可以没有</span></span><br><span class="line">  <span class="comment">// xxx: 12 // error 没有在接口中定义, 不能有</span></span><br><span class="line">&#125;</span><br><span class="line">person2.<span class="property">id</span> = <span class="number">2</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。<br>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">接口可以描述函数类型(参数的类型与返回的类型)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SearchFunc</span> &#123;</span><br><span class="line">  (<span class="attr">source</span>: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span> = <span class="keyword">function</span> (<span class="params">source: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> source.<span class="title function_">search</span>(sub) &gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mySearch</span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><p>类实现接口<br>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">类类型: 实现接口</span></span><br><span class="line"><span class="comment">1. 一个类可以实现多个接口</span></span><br><span class="line"><span class="comment">2. 一个接口可以继承多个接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(): <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">  <span class="title function_">lightOn</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">lightOff</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car alert&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car2</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span>, <span class="title class_">Light</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car alert&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">lightOn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car light on&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">lightOff</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car light off&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------------------------------</span></span><br><span class="line"><span class="comment">// 和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">LightableAlarm</span> <span class="keyword">extends</span> <span class="title class_">Alarm</span>, <span class="title class_">Light</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts的接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts_泛型</title>
      <link href="/2022/08/22/ts-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2022/08/22/ts-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定具体类型的一种特性。</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>下面创建一个函数, 实现功能: 根据指定的数量 <code>count</code> 和数据 <code>value</code> , 创建一个包含 <code>count</code> 个 <code>value</code> 的数组 不用泛型的话，这个函数可能是下面这样：  </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createArray</span>(<span class="params">value: <span class="built_in">any</span>, count: <span class="built_in">number</span></span>): <span class="built_in">any</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">arr</span>: <span class="built_in">any</span>[] = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; count; index++) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="title function_">createArray</span>(<span class="number">11</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="title function_">createArray</span>(<span class="string">&#x27;aa&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1[<span class="number">0</span>].<span class="title function_">toFixed</span>(), arr2[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="使用函数泛型"><a href="#使用函数泛型" class="headerlink" title="使用函数泛型"></a>使用函数泛型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createArray2 &lt;T&gt; (<span class="attr">value</span>: T, <span class="attr">count</span>: <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">arr</span>: <span class="title class_">Array</span>&lt;T&gt; = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; count; index++) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr3 = createArray2&lt;<span class="built_in">number</span>&gt;(<span class="number">11</span>, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3[<span class="number">0</span>].<span class="title function_">toFixed</span>())</span><br><span class="line"><span class="comment">// console.log(arr3[0].split(&#x27;&#x27;)) // error</span></span><br><span class="line"><span class="keyword">const</span> arr4 = createArray2&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;aa&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr4[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="comment">// console.log(arr4[0].toFixed()) // error</span></span><br></pre></td></tr></table></figure><h2 id="多个泛型参数的函数"><a href="#多个泛型参数的函数" class="headerlink" title="多个泛型参数的函数"></a>多个泛型参数的函数</h2><p>一个函数可以定义多个泛型参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> swap &lt;K, V&gt; (<span class="attr">a</span>: K, <span class="attr">b</span>: V): [K, V] &#123;</span><br><span class="line">  <span class="keyword">return</span> [a, b]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = swap&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(<span class="string">&#x27;abc&#x27;</span>, <span class="number">123</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">0</span>].<span class="property">length</span>, result[<span class="number">1</span>].<span class="title function_">toFixed</span>())</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>在定义接口时, 为接口中的属性或方法定义泛型类型<br>在使用接口时, 再指定具体的泛型类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IbaseCRUD</span> &lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">data</span>: T[]</span><br><span class="line">  <span class="attr">add</span>: <span class="function">(<span class="params">t: T</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="attr">getById</span>: <span class="function">(<span class="params">id: <span class="built_in">number</span></span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  id?: <span class="built_in">number</span>; <span class="comment">//id主键自增</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; <span class="comment">//姓名</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (name, age) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserCRUD</span> <span class="keyword">implements</span> <span class="title class_">IbaseCRUD</span> &lt;<span class="title class_">User</span>&gt; &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">User</span>[] = []</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">user</span>: <span class="title class_">User</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    user = &#123;...user, <span class="attr">id</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>()&#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(user)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;保存user&#x27;</span>, user.<span class="property">id</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getById</span>(<span class="attr">id</span>: <span class="built_in">number</span>): <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span>===id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userCRUD = <span class="keyword">new</span> <span class="title class_">UserCRUD</span>()</span><br><span class="line">userCRUD.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;tom&#x27;</span>, <span class="number">12</span>))</span><br><span class="line">userCRUD.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;tom2&#x27;</span>, <span class="number">13</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userCRUD.<span class="property">data</span>)</span><br></pre></td></tr></table></figure><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>在定义类时, 为类中的属性或方法定义泛型类型 在创建类的实例时, 再指定特定的泛型类型  </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">zeroValue</span>: T</span><br><span class="line">  <span class="attr">add</span>: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">myGenericNumber.<span class="property">zeroValue</span> = <span class="number">0</span></span><br><span class="line">myGenericNumber.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericString = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">myGenericString.<span class="property">zeroValue</span> = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">myGenericString.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myGenericString.<span class="title function_">add</span>(myGenericString.<span class="property">zeroValue</span>, <span class="string">&#x27;test&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myGenericNumber.<span class="title function_">add</span>(myGenericNumber.<span class="property">zeroValue</span>, <span class="number">12</span>))</span><br></pre></td></tr></table></figure><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>如果我们直接对一个泛型参数取 <code>length</code> 属性, 会报错, 因为这个泛型根本就不知道它有这个属性  </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有泛型约束</span></span><br><span class="line"><span class="keyword">function</span> fn &lt;T&gt;(<span class="attr">x</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(x.length)  // error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用泛型约束来实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定泛型约束</span></span><br><span class="line"><span class="keyword">function</span> fn2 &lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">x</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">length</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要传入符合约束类型的值，必须包含必须 <code>length</code> 属性：  </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn2</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="comment">// fn2(123) // error  number没有length属性</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts的泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts_类</title>
      <link href="/2022/08/22/ts-%E7%B1%BB/"/>
      <url>/2022/08/22/ts-%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="ts类"><a href="#ts类" class="headerlink" title="ts类"></a>ts类</h2><p>对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">类的基本定义与使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// 声明属性</span></span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">message</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">message</span> = message</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一般方法</span></span><br><span class="line">  greet (): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello &#x27;</span> + <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类的实例</span></span><br><span class="line"><span class="keyword">const</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"><span class="comment">// 调用实例的方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeter.<span class="title function_">greet</span>())</span><br></pre></td></tr></table></figure><p>如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 Greeter 类。这个类有 3 个成员：一个叫做 message 的属性，一个构造函数和一个 greet 方法。</p><p>你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。</p><p>后面一行，我们使用 new 构造了 Greeter 类的一个实例。它会调用之前定义的构造函数，创建一个 Greeter 类型的新对象，并执行构造函数初始化它。</p><p>最后一行通过 greeter 对象调用其 greet 方法</p><hr><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p><p>看下面的例子：<br>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，<code>Dog</code> 是一个 派生类，它派生自 <code>Animal</code> 基类，通过 <code>extends</code> 关键字。 派生类通常被称作子类，基类通常被称作超类。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">类的继承</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  run (<span class="attr">distance</span>: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Animal run <span class="subst">$&#123;distance&#125;</span>m`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  cry () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;wang! wang!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br><span class="line">dog.<span class="title function_">cry</span>() </span><br><span class="line">dog.<span class="title function_">run</span>(<span class="number">100</span>) <span class="comment">// 可以调用从父中继承得到的方法</span></span><br></pre></td></tr></table></figure><p>下面我们来看个更加复杂的例子。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">name</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run (<span class="attr">distance</span>: <span class="built_in">number</span>=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> run <span class="subst">$&#123;distance&#125;</span>m`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">name</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用父类型构造方法</span></span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写父类型的方法</span></span><br><span class="line">  run (<span class="attr">distance</span>: <span class="built_in">number</span>=<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sliding...&#x27;</span>)</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">run</span>(distance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">name</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用父类型构造方法</span></span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写父类型的方法</span></span><br><span class="line">  run (<span class="attr">distance</span>: <span class="built_in">number</span>=<span class="number">50</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;dashing...&#x27;</span>)</span><br><span class="line">    <span class="comment">// 调用父类型的一般方法</span></span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">run</span>(distance)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  xxx () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;xxx()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> snake = <span class="keyword">new</span> <span class="title class_">Snake</span>(<span class="string">&#x27;sn&#x27;</span>)</span><br><span class="line">snake.<span class="title function_">run</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> horse = <span class="keyword">new</span> <span class="title class_">Horse</span>(<span class="string">&#x27;ho&#x27;</span>)</span><br><span class="line">horse.<span class="title function_">run</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类型引用指向子类型的实例 ==&gt; 多态</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tom</span>: <span class="title class_">Animal</span> = <span class="keyword">new</span> <span class="title class_">Horse</span>(<span class="string">&#x27;ho22&#x27;</span>)</span><br><span class="line">tom.<span class="title function_">run</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果子类型没有扩展的方法, 可以让子类型引用指向父类型的实例 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tom3</span>: <span class="title class_">Snake</span> = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;tom3&#x27;</span>)</span><br><span class="line">tom3.<span class="title function_">run</span>()</span><br><span class="line"><span class="comment">/* 如果子类型有扩展的方法, 不能让子类型引用指向父类型的实例 */</span></span><br><span class="line"><span class="comment">// const tom2: Horse = new Animal(&#x27;tom2&#x27;)</span></span><br><span class="line"><span class="comment">// tom2.run()</span></span><br></pre></td></tr></table></figure><p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用 extends 关键字创建了 Animal的两个子类：Horse 和 Snake。</p><p>与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this 的属性之前，我们 一定要调用 super()。 这个是 TypeScript 强制执行的一条重要规则。</p><p>这个例子演示了如何在子类里可以重写父类的方法。Snake类和 Horse 类都创建了 run 方法，它们重写了从 Animal 继承来的 run 方法，使得 run 方法根据不同的类而具有不同的功能。注意，即使 tom 被声明为 Animal 类型，但因为它的值是 Horse，调用 tom.run(34) 时，它会调用 Horse 里重写的方法。</p><hr><h2 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h2><ol><li>认为 public<br>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 public 来做修饰；例如，C# 要求必须明确地使用 public 指定成员是可见的。 在 TypeScript 里，成员都默认为 public。<br>你也可以明确的将一个成员标记成 public。 我们可以用下面的方式来重写上面的 Animal 类：</li><li>理解 private<br>当成员被标记成 private 时，它就不能在声明它的类的外部访问。</li><li>理解 protected<br>protected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。例如：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">访问修饰符: 用来描述类内部的属性/方法的可访问性</span></span><br><span class="line"><span class="comment">  public: 默认值, 公开的外部也可以访问 公共的</span></span><br><span class="line"><span class="comment">  private: 只能类内部可以访问 私有的</span></span><br><span class="line"><span class="comment">  protected: 类内部和子类可以访问  受保护的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span> (<span class="attr">name</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> run (<span class="attr">distance</span>: <span class="built_in">number</span>=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> run <span class="subst">$&#123;distance&#125;</span>m`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">sex</span>: <span class="built_in">string</span> = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"></span><br><span class="line">  run (<span class="attr">distance</span>: <span class="built_in">number</span>=<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person jumping...&#x27;</span>)</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">run</span>(distance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  run (<span class="attr">distance</span>: <span class="built_in">number</span>=<span class="number">6</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Student jumping...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sex</span>) <span class="comment">// 子类能看到父类中受保护的成员</span></span><br><span class="line">    <span class="comment">// console.log(this.age) //  子类看不到父类中私有的成员</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">run</span>(distance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;abc&#x27;</span>).<span class="property">name</span>) <span class="comment">// 公开的可见</span></span><br><span class="line"><span class="comment">// console.log(new Person(&#x27;abc&#x27;).sex) // 受保护的不可见</span></span><br><span class="line"><span class="comment">// console.log(new Person(&#x27;abc&#x27;).age) //  私有的不可见</span></span><br></pre></td></tr></table></figure><ol start="4"><li>readonly 修饰符<br>你可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;John&#x27;</span>)</span><br><span class="line"><span class="comment">// john.name = &#x27;peter&#x27; // error</span></span><br></pre></td></tr></table></figure><ol start="5"><li>参数属性<br>在上面的例子中，我们必须在 Person 类里定义一个只读成员 name 和一个参数为 name 的构造函数，并且立刻将 name 的值赋给 this.name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Person 类的修改版，使用了参数属性：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">readonly</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person2</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>)</span><br></pre></td></tr></table></figure><p>注意看我们是如何舍弃参数 name，仅在构造函数里使用 readonly name: string 参数来创建和初始化 name 成员。 我们把声明和赋值合并至一处。</p><p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 private 限定一个参数属性会声明并初始化一个私有成员；对于 public 和 protected 来说也是一样。</p><hr><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>TypeScript 支持通过 getters&#x2F;setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。<br>我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对 fullName的直接访问改成了可以检查密码的 set方法。 我们也加了一个 get方法，让上面的例子仍然可以工作。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">&quot;secret passcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_fullName</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">fullName</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_fullName</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">&quot;secret passcode&quot;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_fullName</span> = newName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error: Unauthorized update of employee!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">employee.<span class="property">fullName</span> = <span class="string">&quot;Bob Smith&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.<span class="property">fullName</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(employee.<span class="property">fullName</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带有 <code>get</code>不带有 <code>set</code>的存取器自动被推断为 <code>readonly</code>。</p><hr><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 static定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin前面加上类名。 如同在实例属性上使用 this.前缀来访问属性一样，这里我们使用 Grid.来访问静态属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grid</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> origin = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="title function_">calculateDistanceFromOrigin</span>(<span class="params">point: &#123;x: <span class="built_in">number</span>; y: <span class="built_in">number</span>;&#125;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> xDist = (point.<span class="property">x</span> - <span class="title class_">Grid</span>.<span class="property">origin</span>.<span class="property">x</span>);</span><br><span class="line">        <span class="keyword">let</span> yDist = (point.<span class="property">y</span> - <span class="title class_">Grid</span>.<span class="property">origin</span>.<span class="property">y</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(xDist * xDist + yDist * yDist) / <span class="variable language_">this</span>.<span class="property">scale</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructor</span> (<span class="keyword">public</span> <span class="attr">scale</span>: <span class="built_in">number</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> <span class="title class_">Grid</span>(<span class="number">1.0</span>);  <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> <span class="title class_">Grid</span>(<span class="number">5.0</span>);  <span class="comment">// 5x scale</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grid1.<span class="title function_">calculateDistanceFromOrigin</span>(&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grid2.<span class="title function_">calculateDistanceFromOrigin</span>(&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Grid</span>().<span class="property">origin</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类做为其它派生类的基类使用。 它们不能被实例化。不同于接口，抽象类可以包含成员的实现细节。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">printName</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Department name: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">printMeeting</span>(): <span class="built_in">void</span>; <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountingDepartment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Department</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(<span class="string">&#x27;Accounting and Auditing&#x27;</span>); <span class="comment">// 在派生类的构造函数中必须调用 super()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">printMeeting</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The Accounting Department meets each Monday at 10am.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">generateReports</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generating accounting reports...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">department</span>: <span class="title class_">Department</span>; <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">Department</span>(); <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">AccountingDepartment</span>(); <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.<span class="title function_">printName</span>();</span><br><span class="line">department.<span class="title function_">printMeeting</span>();</span><br><span class="line">department.<span class="title function_">generateReports</span>(); <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts的类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts_类型</title>
      <link href="/2022/08/16/ts_%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/08/16/ts_%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><blockquote><p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p></blockquote><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>最基本的数据类型就是简单的true&#x2F;false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a1</span>: <span class="built_in">number</span> = <span class="number">10</span> <span class="comment">//十进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a2</span>: <span class="built_in">number</span> = <span class="number">0b1010</span> <span class="comment">//二进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a3</span>: <span class="built_in">number</span> = <span class="number">0o12</span> <span class="comment">//八进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a4</span>: <span class="built_in">number</span> = <span class="number">0xa</span> <span class="comment">//十六进制</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1);<span class="comment">//10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2);<span class="comment">//10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a3);<span class="comment">//10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a4);<span class="comment">//10</span></span><br></pre></td></tr></table></figure><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号（ “）或单引号（’）表示字符串。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">firstName</span>: <span class="built_in">string</span> = <span class="string">&#x27;东方&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">lastName</span>: <span class="built_in">string</span> = <span class="string">&#x27;不败&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a><code>null</code> 和 <code>undefined</code></h2><p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型，就是说可以把<code>null</code>和<code>undefined</code>赋值给其他类型  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>:<span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>:<span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</p><p>然而，当你指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string或null或undefined，你可以使用联合类型string | null | undefined。 再次说明，稍后我们会介绍联合类型。</p><blockquote><p>注意：我们鼓励尽可能地使用–strictNullChecks，但在本手册里我们假设这个标记是关闭的。</p></blockquote><h2 id="元祖-Tuple"><a href="#元祖-Tuple" class="headerlink" title="元祖 Tuple"></a>元祖 Tuple</h2><p>元组类型允许表示一个已知元素数量和类型的数组，<code>各元素的类型不必相同</code>。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">t1</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line">t1 = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>] <span class="comment">// OK</span></span><br><span class="line">t1 = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>] <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// 当访问一个已知索引的元素，会得到正确的类型：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t1[<span class="number">0</span>].<span class="title function_">substring</span>(<span class="number">1</span>)) <span class="comment">// OK</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t1[<span class="number">1</span>].<span class="title function_">substring</span>(<span class="number">1</span>)) <span class="comment">// Error, &#x27;number&#x27; 不存在 &#x27;substring&#x27; 方法</span></span><br><span class="line"><span class="comment">// 当访问一个越界的元素，会使用联合类型替代：</span></span><br><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">5</span>].<span class="title function_">toString</span>()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 使用枚举类型可以<code>为一组数值赋予友好的名字</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举数值默认从0开始依次递增</span></span><br><span class="line"><span class="comment">// 根据特定的名称得到对应的枚举数值</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myColor</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Red</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myColor, <span class="title class_">Color</span>.<span class="property">Green</span>, <span class="title class_">Color</span>.<span class="property">Blue</span>) <span class="comment">// 0,1,2</span></span><br></pre></td></tr></table></figure><p>默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>或者，全部都采用手动赋值：  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span> = <span class="number">2</span>, <span class="title class_">Blue</span> = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">colorName</span>: <span class="built_in">string</span> = <span class="title class_">Color</span>[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colorName)  <span class="comment">// &#x27;Green&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line">notSure = <span class="string">&#x27;maybe a string&#x27;</span></span><br><span class="line">notSure = <span class="literal">false</span> <span class="comment">// 也可以是个 boolean</span></span><br></pre></td></tr></table></figure><p>在对现有代码进行改写的时候，any 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，any 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">prettySure</span>: <span class="title class_">Object</span> = <span class="number">4</span>;</span><br><span class="line">prettySure.<span class="title function_">toFixed</span>(); <span class="comment">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure><h2 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h2><p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示<code>没有任何类型</code>。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。<br>使用object类型，就可以更好的表示像Object.create这样的API。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">obj:<span class="built_in">object</span></span>):<span class="built_in">object</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2()&#x27;</span>, obj)</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  <span class="comment">// return undefined</span></span><br><span class="line">  <span class="comment">// return null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn2</span>(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>)))</span><br><span class="line"><span class="comment">// console.log(fn2(&#x27;abc&#x27;) // error</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn2</span>(<span class="title class_">String</span>))</span><br></pre></td></tr></table></figure><h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。<br>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。<br>下面是一些返回never类型的函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">error</span>(<span class="string">&quot;Something failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）表示取值可以为多种类型中的一种<br>需求1: 定义一个一个函数得到一个数字或字符串值的字符串形式值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString2</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) : <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求2: 定义一个一个函数得到一个数字或字符串值的长度</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="comment">// return x.length // error</span></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="property">length</span>) &#123; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">return</span> x.<span class="property">length</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="title function_">toString</span>().<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。<br>类型断言有两种形式。 其一是“尖括号”语法, 另一个为 as 语法  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">类型断言(Type Assertion): 可以用来手动指定一个值的类型</span></span><br><span class="line"><span class="comment">语法:</span></span><br><span class="line"><span class="comment">    方式一: &lt;类型&gt;值</span></span><br><span class="line"><span class="comment">    方式二: 值 as 类型  tsx中只能用这种方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 需求: 定义一个函数得到一个字符串或者数值数据的长度 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((&lt;<span class="built_in">string</span>&gt;x).<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (x <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="title function_">toString</span>().<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getLength</span>(<span class="string">&#x27;abcd&#x27;</span>), <span class="title function_">getLength</span>(<span class="number">1234</span>))</span><br></pre></td></tr></table></figure><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>类型推断: TS会在没有明确的指定类型的时候推测出一个类型<br>有下面2种情况:</p><ol><li>定义变量时赋值了, 推断为对应的类型.</li><li>定义变量时没有赋值, 推断为any类型</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义变量时赋值了, 推断为对应的类型 */</span></span><br><span class="line"><span class="keyword">let</span> b9 = <span class="number">123</span> <span class="comment">// number</span></span><br><span class="line"><span class="comment">// b9 = &#x27;abc&#x27; // error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义变量时没有赋值, 推断为any类型 */</span></span><br><span class="line"><span class="keyword">let</span> b10  <span class="comment">// any类型</span></span><br><span class="line">b10 = <span class="number">123</span></span><br><span class="line">b10 = <span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="交叉类型（Intersection-Types）"><a href="#交叉类型（Intersection-Types）" class="headerlink" title="交叉类型（Intersection Types）"></a>交叉类型（Intersection Types）</h2><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。</p><p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在JavaScript里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Loggable</span> &#123;</span><br><span class="line">    <span class="title function_">log</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsoleLogger</span> <span class="keyword">implements</span> <span class="title class_">Loggable</span> &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jim = <span class="title function_">extend</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jim&quot;</span>), <span class="keyword">new</span> <span class="title class_">ConsoleLogger</span>());</span><br><span class="line"><span class="keyword">let</span> n = jim.<span class="property">name</span>;</span><br><span class="line">jim.<span class="title function_">log</span>();</span><br><span class="line"><span class="keyword">function</span> extend&lt;T, U&gt;(<span class="attr">first</span>: T, <span class="attr">second</span>: U): T &amp; U &#123;</span><br><span class="line">    <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">    for (let id in first) &#123;</span><br><span class="line">        (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    for (let id in second) &#123;</span><br><span class="line">        if (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">            (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts的类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3的响应式原理</title>
      <link href="/2022/08/12/vue3%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/12/vue3%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="vue3的响应式原理"><a href="#vue3的响应式原理" class="headerlink" title="vue3的响应式原理"></a>vue3的响应式原理</h1><ul><li>通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy"><code>Proxy</code></a>(代理):拦截对data(数据)任意属性的任意(13种)操作，包括属性的读写，添加，删除等等……</li><li>通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect"><code>Reflect</code></a>(反射): 动态对被代理的对象的相应属性进行特定的操作</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MonsterHunter</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;无名氏&#x27;</span>,</span><br><span class="line">    <span class="attr">title</span>:[<span class="string">&#x27;新大陆的白凤&#x27;</span>,<span class="string">&#x27;指引明路的苍蓝星&#x27;</span>],</span><br><span class="line">    <span class="attr">level</span>:<span class="string">&#x27;100&#x27;</span>,</span><br><span class="line">    <span class="attr">armor</span>:&#123;</span><br><span class="line">        <span class="attr">head</span>:<span class="string">&#x27;精英·龙头头盔贝塔&#x27;</span>,</span><br><span class="line">        <span class="attr">jacket</span>:<span class="string">&#x27;精英·龙皮贝塔&#x27;</span>,</span><br><span class="line">        <span class="attr">hand</span>:<span class="string">&#x27;精英·龙岗爪贝塔&#x27;</span>,</span><br><span class="line">        <span class="attr">trousers</span>:<span class="string">&#x27;精英·龙脊阿尔法&#x27;</span>,</span><br><span class="line">        <span class="attr">shoes</span>:<span class="string">&#x27;精英·龙靴贝塔&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Weapon:&#x27;黑龙歼灭刀&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> porxyMonsterHunter = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">MonsterHunter</span>, &#123;</span><br><span class="line">    <span class="comment">// 读写</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, prop</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get方法调用了&#x27;</span>);</span><br><span class="line">        <span class="comment">// 注意必须把target, prop反射出去，否则报undefined</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 新增，修改</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, prop, val</span>)&#123;</span><br><span class="line">        <span class="comment">// 注意必须把target, prop，val反射出去，否则修改不会成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, val)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="title function_">deleteProperty</span>(<span class="params">target, prop</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;prop&#125;</span>：啊！我被删除了`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 读写</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(porxyMonsterHunter.<span class="property">name</span>) <span class="comment">//get方法调用了 无名氏</span></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">porxyMonsterHunter.<span class="property">level</span> = <span class="string">&#x27;999&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MonsterHunter</span>.<span class="property">level</span>); <span class="comment">// 999</span></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">porxyMonsterHunter.<span class="property">Weapon</span> = <span class="string">&#x27;黑龙歼灭刀&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MonsterHunter</span>.<span class="property">Weapon</span>); <span class="comment">// 黑龙歼灭刀</span></span><br><span class="line"><span class="keyword">delete</span> porxyMonsterHunter.<span class="property">Weapon</span>   <span class="comment">// Weapon：啊！我被删除了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MonsterHunter</span>.<span class="property">Weapon</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> 响应式原理 </tag>
            
            <tag> Proxy </tag>
            
            <tag> Reflect </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
